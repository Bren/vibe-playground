<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logic Crossword - drorbren.com</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.ico">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            padding: 2rem;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            text-align: center;
            padding: 0 20px;
        }
        
        h1 {
            font-size: 3rem;
            font-weight: 300;
            margin-bottom: 2rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .nav {
            margin-bottom: 3rem;
        }
        
        .nav a {
            color: white;
            text-decoration: none;
            margin: 0 1rem;
            padding: 0.5rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        .nav a:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .content {
            background: rgba(255, 255, 255, 0.1);
            padding: 2rem;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        p {
            font-size: 1.2rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }
        
        /* Upload Section Styles */
        .upload-section {
            margin-bottom: 3rem;
        }
        
        h2 {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            font-weight: 300;
        }
        
        .file-upload-container {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }
        
        .file-upload {
            flex: 1;
            min-width: 200px;
        }
        
        .file-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .file-label:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .file-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        
        .file-text {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .file-status {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            min-height: 1.2rem;
        }
        
        .file-status.uploaded {
            color: #4ade80;
        }
        
        .file-status.error {
            color: #f87171;
        }
        
        .extract-button {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .extract-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
        }
        
        .extract-button:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        /* Results Section Styles */
        .results-section {
            margin-top: 2rem;
        }
        
        .table-container {
            overflow-x: auto;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            margin: 20px 0;
            width: 100%;
        }
        
        .results-table {
            width: 100%;
            min-width: 1200px;
            border-collapse: collapse;
            background: transparent;
            table-layout: fixed;
        }
        
        .results-table th {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            text-align: left;
            font-weight: 500;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .results-table td {
            padding: 1.2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            vertical-align: top;
        }
        
        /* Column width constraints - wider layout for better readability */
        .results-table th:nth-child(1),
        .results-table td:nth-child(1) {
            width: 6%;
            text-align: center;
            min-width: 50px;
        }
        
        .results-table th:nth-child(2),
        .results-table td:nth-child(2) {
            width: 6%;
            text-align: center;
            min-width: 50px;
        }
        
        .results-table th:nth-child(3),
        .results-table td:nth-child(3) {
            width: 10%;
            text-align: center;
            min-width: 80px;
        }
        
        .results-table th:nth-child(4),
        .results-table td:nth-child(4) {
            width: 58%;
            word-break: break-word;
            white-space: normal;
            min-width: 400px;
        }
        
        .results-table th:nth-child(5),
        .results-table td:nth-child(5) {
            width: 20%;
            text-align: center;
            min-width: 150px;
        }
        
        .results-table tbody tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .nav a {
                display: block;
                margin: 0.5rem 0;
            }
            
            .file-upload-container {
                flex-direction: column;
                gap: 1rem;
            }
            
            .file-label {
                padding: 1.5rem;
            }
            
            .results-table th,
            .results-table td {
                padding: 0.5rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="index.html">Home</a>
            <a href="logic-crossword.html">Logic Crossword</a>
        </nav>
        
        <h1>Logic Crossword</h1>
        
        <div class="content">
            <div class="upload-section">
                <h2>Upload Files</h2>
                <div class="file-upload-container">
                    <div class="file-upload">
                        <label for="file1" class="file-label">
                            <span class="file-icon">📄</span>
                            <span class="file-text">Add Clues File</span>
                            <input type="file" id="file1" accept=".txt,.pdf,.doc,.docx" style="display: none;">
                        </label>
                        <div id="file1-status" class="file-status"></div>
                    </div>
                    
                    <div class="file-upload">
                        <label for="file2" class="file-label">
                            <span class="file-icon">📄</span>
                            <span class="file-text">Add Answers File</span>
                            <input type="file" id="file2" accept=".txt,.pdf,.doc,.docx" style="display: none;">
                        </label>
                        <div id="file2-status" class="file-status"></div>
                    </div>
                </div>
                
                <button id="extract-btn" class="extract-button" disabled>
                    Extract Clues and Answers
                </button>
            </div>
            
            <div style="margin-top: 20px; text-align: center;">
                <button onclick="clearCache()" style="background: #ff9800; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">
                    Clear Cache
                </button>
            </div>
            
            <div class="results-section">
                <h2>Results</h2>
                <div class="table-container">
                    <table id="results-table" class="results-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>H/V</th>
                                <th>Start Cell</th>
                                <th>Clue</th>
                                <th>Answer</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Results will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // File upload handling
        let uploadedFiles = { file1: null, file2: null };
        
        // Clear any cached data
        function clearCache() {
            uploadedFiles = { file1: null, file2: null };
            document.getElementById('results-table').querySelector('tbody').innerHTML = '';
            // Clear any global variables that might be holding data
            if (typeof window.lastDocumentStructure !== 'undefined') {
                delete window.lastDocumentStructure;
            }
            console.log('Cache cleared completely');
        }
        
        function updateExtractButton() {
            const extractBtn = document.getElementById('extract-btn');
            const bothFilesUploaded = uploadedFiles.file1 && uploadedFiles.file2;
            extractBtn.disabled = !bothFilesUploaded;
        }
        
        function handleFileUpload(fileInput, fileNumber) {
            const file = fileInput.files[0];
            const statusElement = document.getElementById(`file${fileNumber}-status`);
            
            if (file) {
                uploadedFiles[`file${fileNumber}`] = file;
                statusElement.textContent = `✅ ${file.name} uploaded`;
                statusElement.className = 'file-status uploaded';
            } else {
                uploadedFiles[`file${fileNumber}`] = null;
                statusElement.textContent = '';
                statusElement.className = 'file-status';
            }
            
            updateExtractButton();
        }
        
        // Event listeners
        document.getElementById('file1').addEventListener('change', function() {
            handleFileUpload(this, 1);
        });
        
        document.getElementById('file2').addEventListener('change', function() {
            handleFileUpload(this, 2);
        });
        
        document.getElementById('extract-btn').addEventListener('click', function() {
            if (uploadedFiles.file1 && uploadedFiles.file2) {
                extractDocumentData(uploadedFiles.file1, uploadedFiles.file2);
            }
        });
        
        // Document extraction logic
        async function extractDocumentData(cluesFile, answersFile) {
            try {
                console.log('Starting extraction from:', cluesFile.name, 'and', answersFile.name);
                
                // Extract text from both files
                const cluesText = await extractTextFromFile(cluesFile);
                const answersText = await extractTextFromFile(answersFile);
                
                console.log('=== EXTRACTION RESULTS ===');
                console.log('Clues file:', cluesFile.name);
                console.log('Answers file:', answersFile.name);
                console.log('Clues text length:', cluesText.length);
                console.log('Answers text length:', answersText.length);
                console.log('Clues text preview:', cluesText.substring(0, 500));
                console.log('Answers text preview:', answersText.substring(0, 500));
                
                // Parse document structure
                const documentStructure = parseDocumentStructure(cluesText, answersText);
                
                console.log('Document structure:', documentStructure);
                
                // Display results in table
                displayResults(documentStructure);
                
            } catch (error) {
                console.error('Extraction failed:', error);
                alert('Extraction failed: ' + error.message);
            }
        }
        
        // Extract text from file (PDF or text)
        async function extractTextFromFile(file) {
            return new Promise((resolve, reject) => {
                if (file.type === 'application/pdf') {
                    // Handle PDF files with PDF.js
                    const reader = new FileReader();
                    
                    reader.onload = async function(e) {
                        try {
                            const arrayBuffer = e.target.result;
                            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                            let fullText = '';
                            
                            // Extract text from all pages
                            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                                const page = await pdf.getPage(pageNum);
                                const textContent = await page.getTextContent();
                                const pageText = textContent.items.map(item => item.str).join(' ');
                                fullText += pageText + '\n';
                            }
                            
                            resolve(fullText);
                        } catch (error) {
                            reject(new Error('Failed to parse PDF: ' + error.message));
                        }
                    };
                    
                    reader.onerror = function() {
                        reject(new Error('Failed to read PDF file'));
                    };
                    
                    reader.readAsArrayBuffer(file);
                } else {
                    // Handle text files
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        resolve(e.target.result);
                    };
                    
                    reader.onerror = function() {
                        reject(new Error('Failed to read text file'));
                    };
                    
                    reader.readAsText(file);
                }
            });
        }
        
        // Parse document structure
        function parseDocumentStructure(cluesText, answersText) {
            try {
                // Extract clues from the clues document
                const clues = extractClues(cluesText);
                
                // Extract answers from the answers document
                const answers = extractAnswers(answersText);
                
                // Match clues with answers
                const matchedClues = matchCluesWithAnswers(clues, answers);
                
                // Extract grid from the answers document
                const grid = extractGrid(answersText);
                
                return {
                    clues: matchedClues,
                    answers: answers,
                    grid: grid,
                    status: 'success'
                };
            } catch (error) {
                console.error('Parsing error:', error);
                return {
                    clues: { horizontal: [], vertical: [] },
                    grid: { size: { rows: 0, cols: 0 }, cells: {} },
                    status: 'error',
                    error: error.message
                };
            }
        }
        
        // Extract answers from the solution section (פתרון תשבץ הגיון) - CLEAN VERSION
        function extractAnswers(text) {
            console.log('=== CLEAN ANSWER EXTRACTION ===');
            
            // Step 1: Find the solution section
            const solutionMatch = text.match(/פתרון תשבץ הגיון[^]*?מאוזן:\s*(.*?)מאונך:\s*(.*?)(?=לוח המשחק|מנוי שבועי|$)/s);
            
            if (!solutionMatch) {
                console.log('❌ No solution section found');
                return { horizontal: [], vertical: [] };
            }
            
            const horizontalText = solutionMatch[1].trim();
            const verticalText = solutionMatch[2].trim();
            
            console.log('✅ Found horizontal answers:', horizontalText);
            console.log('✅ Found vertical answers:', verticalText);
            
            // Step 2: Parse answers from each section
            const horizontalAnswers = parseSimpleAnswers(horizontalText, 'H');
            const verticalAnswers = parseSimpleAnswers(verticalText, 'V');
            
            console.log(`📊 Extracted ${horizontalAnswers.length} horizontal + ${verticalAnswers.length} vertical answers`);
            
            return {
                horizontal: horizontalAnswers,
                vertical: verticalAnswers
            };
        }
        
        // Parse answers in simple format: "14. שעורי בית 16. אל אזהר 18. עבודתו"
        function parseSimpleAnswers(text, direction) {
            const answers = [];
            
            // Split by number-period pattern: "14. text 16. text"
            const parts = text.split(/(?=\d+\.)/);
            
            parts.forEach(part => {
                part = part.trim();
                if (!part) return;
                
                const match = part.match(/^(\d+)\.\s*([א-ת][^]*?)(?=\s*$)/);
                if (match) {
                    const number = parseInt(match[1]);
                    const answerText = match[2].trim();
                    
                    if (answerText && /[א-ת]/.test(answerText)) {
                        answers.push({
                            number: number,
                            text: answerText,
                            direction: direction
                        });
                        console.log(`  📝 ${number}${direction}: ${answerText}`);
                    }
                }
            });
            
            return answers;
        }
        
        // Parse solutions from the solution section 
        function parseSolutionsFromText(sectionText, sectionType) {
            const answers = [];
            
            console.log('Parsing solutions from:', sectionType, 'section:', sectionText);
            
            let textToParse = '';
            
            if (sectionType === 'horizontal') {
                // Look for text between מאוזן: and מאונך:
                const horizontalMatch = sectionText.match(/מאוזן:\s*(.*?)(?=מאונך:|$)/s);
                if (horizontalMatch) {
                    textToParse = horizontalMatch[1].trim();
                }
            } else if (sectionType === 'vertical') {
                // Look for text after מאונך:
                const verticalMatch = sectionText.match(/מאונך:\s*(.*?)$/s);
                if (verticalMatch) {
                    textToParse = verticalMatch[1].trim();
                }
            }
            
            console.log('Text to parse for', sectionType, ':', textToParse);
            
            if (!textToParse) {
                console.log('No text found for', sectionType);
                return answers;
            }
            
            // Parse format like: "17. אתניקס 19. רדה 20. אלבינוני 23. ברברה 24. דן חמיצר"
            // Split by number followed by period, but keep the number
            const parts = textToParse.split(/(?=\d+\.)/);
            
            parts.forEach(part => {
                part = part.trim();
                if (!part) return;
                
                // Match pattern: "number. Hebrew text" (may contain spaces)
                const match = part.match(/^(\d+)\.\s*([א-ת][א-ת\s]*?)(?=\s*\d+\.|$)/);
                if (match) {
                    const number = parseInt(match[1]);
                    let answerText = match[2].trim();
                    
                    // Clean up extra spaces but preserve Hebrew text
                    answerText = answerText.replace(/\s+/g, ' ').trim();
                    
                    if (answerText.length > 0 && /[א-ת]/.test(answerText)) {
                        const answer = {
                            number: number,
                            text: answerText,
                            type: sectionType
                        };
                        
                        console.log('Extracted solution:', answer);
                        answers.push(answer);
                    }
                } else {
                    console.log('No match for part:', part);
                }
            });
            
            return answers;
        }
        
        // Match clues with their corresponding answers
        function matchCluesWithAnswers(clues, answers) {
            console.log('=== MATCHING CLUES WITH ANSWERS ===');
            
            // Create lookup maps for answers
            const horizontalAnswerMap = new Map();
            const verticalAnswerMap = new Map();
            
            answers.horizontal.forEach(answer => {
                horizontalAnswerMap.set(answer.number, answer.text);
            });
            
            answers.vertical.forEach(answer => {
                verticalAnswerMap.set(answer.number, answer.text);
            });
            
            // Match horizontal clues with answers
            const matchedHorizontalClues = clues.horizontal.map(clue => {
                const answer = horizontalAnswerMap.get(clue.number);
                return {
                    ...clue,
                    answer: answer || 'TBD'
                };
            });
            
            // Match vertical clues with answers
            const matchedVerticalClues = clues.vertical.map(clue => {
                const answer = verticalAnswerMap.get(clue.number);
                return {
                    ...clue,
                    answer: answer || 'TBD'
                };
            });
            
            console.log('Matched horizontal clues:', matchedHorizontalClues.length);
            console.log('Matched vertical clues:', matchedVerticalClues.length);
            
            return {
                horizontal: matchedHorizontalClues,
                vertical: matchedVerticalClues
            };
        }
        
        // Extract clues from text - CLEAN VERSION
        function extractClues(text) {
            console.log('=== CLEAN CLUE EXTRACTION ===');
            
            // Step 1: Find horizontal and vertical sections
            const horizontalMatch = text.match(/מאוזן:\s*(.*?)(?=מאונך:|פתרון|$)/s);
            const verticalMatch = text.match(/מאונך:\s*(.*?)(?=פתרון|$)/s);
            
            const horizontalClues = horizontalMatch ? parseSimpleClues(horizontalMatch[1].trim(), 'H') : [];
            const verticalClues = verticalMatch ? parseSimpleClues(verticalMatch[1].trim(), 'V') : [];
            
            console.log(`📊 Extracted ${horizontalClues.length} horizontal + ${verticalClues.length} vertical clues`);
            
            return {
                horizontal: horizontalClues,
                vertical: verticalClues
            };
        }
        
        // Parse clues in simple format: "14. הלורד נבחן (3,3); 16. text (4);"
        function parseSimpleClues(text, direction) {
            const clues = [];
            
            // Split by semicolon and number pattern
            const parts = text.split(';');
            
            parts.forEach(part => {
                part = part.trim();
                if (!part) return;
                
                const match = part.match(/^(\d+)\.\s*(.+)$/);
                if (match) {
                    const number = parseInt(match[1]);
                    const clueText = match[2].trim();
                    
                    if (clueText && clueText.length > 3) {
                        clues.push({
                            number: number,
                            direction: direction,
                            text: clueText,
                            type: direction === 'H' ? 'horizontal' : 'vertical'
                        });
                        console.log(`  🧩 ${number}${direction}: ${clueText}`);
                    }
                }
            });
            
            return clues;
        }
                // Handle both semicolon-separated format and space-separated format
                // For semicolon format: "1. text (length); 5. text (length);"
                // For space format: "1. text (length) 7. text (length)"
                const clueMatches = sectionText.match(/(\d+\.\s+[^]*?(?=\d+\.|$))/g);
                
                if (clueMatches) {
                    for (const clueMatch of clueMatches) {
                        // Extract clue number
                        const numberMatch = clueMatch.match(/^(\d+)\./);
                        if (!numberMatch) continue;
                        
                        const clueNumber = parseInt(numberMatch[1]);
                        
                        // Extract clue text (everything after the number and period, up to the answer length)
                        let clueText = clueMatch.replace(/^\d+\.\s*/, '').trim();
                        
                        // Remove trailing semicolon or period
                        clueText = clueText.replace(/[;.]$/, '').trim();
                        
                        // Clean up garbled content like ";6(" or ";)6(" but preserve answer lengths in parentheses
                        clueText = clueText.replace(/[;!]?\d*[;!]?\(/g, '').replace(/\)[;!]?\d*[;!]?/g, '');
                        
                        // For space-separated format, remove trailing numbers that are the next clue number
                        clueText = clueText.replace(/\s+\d+\s*$/, '').trim();
                        
                        // Clean up the clue text more gently - preserve natural structure
                        // Find the answer length (last parentheses with only numbers/commas)
                        const answerLengthMatch = clueText.match(/\(([0-9,]+)\)\s*$/);
                        
                        if (answerLengthMatch) {
                            const answerLength = answerLengthMatch[1];
                            // Remove the answer length from the end
                            clueText = clueText.replace(/\s*\([0-9,]+\)\s*$/, '').trim();
                            // Clean up extra spaces
                            clueText = clueText.replace(/\s+/g, ' ').trim();
                            // Add back the answer length in standard format
                            clueText += ` (${answerLength})`;
                        } else {
                            // Clean up extra spaces
                            clueText = clueText.replace(/\s+/g, ' ').trim();
                        }
                        
                        // Skip if this looks like chess notation, garbled content, or invalid clues
                        if (clueText.includes('פ-') || clueText.includes('צ-') || clueText.includes('מ-') || 
                            clueText.includes('חידת שחמט') || clueText.includes('פתרון החידה') ||
                            clueText.includes('הלבן') || clueText.includes('השחור') ||
                            clueText.includes('τ') || clueText.includes('!') ||
                            clueText.length < 3 || /^[0-9\s\.;:!τ\-]+$/.test(clueText) ||
                            // Additional patterns for garbled content
                            /[τ!][0-9]/.test(clueText) || /[0-9][τ!]/.test(clueText) ||
                            clueText.includes('צ:') || clueText.includes('ז5') ||
                            // Skip very short content or content with no Hebrew
                            clueText.length < 2 || (clueText.match(/[א-ת]/g) || []).length < 1) {
                            console.log('Skipping invalid content:', clueText);
                            continue;
                        }
                        
                        // The answer length is part of the clue text, not separate
                        const direction = sectionType === 'horizontal' ? 'H' : 'V';
                        
                        const clue = {
                            number: clueNumber,
                            direction: direction,
                            text: clueText,
                            answerLength: '', // Answer length is now part of the text
                            type: sectionType
                        };
                        
                        console.log('Parsed clue:', clue);
                        console.log('Raw clue text before filtering:', `"${clueText}"`);
                        clues.push(clue);
                    }
                }
                
                // Post-process to remove any remaining invalid clues
                console.log('Starting post-processing filter on', clues.length, 'clues');
                const validClues = clues.filter(clue => {
                    const text = clue.text;
                    console.log('Checking clue:', text);
                    
                    // Skip if contains garbled characters or chess notation
                    if (text.includes('τ') || text.includes(';') || text.includes('!') ||
                        text.includes('צ:') || text.includes('ז5') || text.includes('פ-') ||
                        text.length < 5 || (text.match(/[א-ת]/g) || []).length < 3) {
                        console.log('Post-filtering out invalid clue:', text);
                        return false;
                    }
                    console.log('Keeping valid clue:', text);
                    return true;
                });
                
                console.log(`Filtered ${clues.length} clues down to ${validClues.length} valid clues`);
                return validClues;
            }
            
            console.log('Final extracted clues:', { horizontal: horizontalClues.length, vertical: verticalClues.length });
            console.log('Horizontal clues:', horizontalClues);
            console.log('Vertical clues:', verticalClues);
            
            return {
                horizontal: horizontalClues,
                vertical: verticalClues
            };
        }
        
        // Extract grid from text
        function extractGrid(text) {
            try {
                // Look for grid patterns in the text
                const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                
                // Find potential grid lines (lines with consistent character patterns)
                const gridLines = findGridLines(lines);
                
                if (gridLines.length === 0) {
                    return {
                        size: { rows: 0, cols: 0 },
                        cells: {},
                        status: 'no_grid_found'
                    };
                }
                
                // Parse the grid structure
                const grid = parseGridStructure(gridLines);
                
                // Extract numbered cells to identify clue numbers
                const numberedCells = extractNumberedCells(grid);
                grid.numberedCells = numberedCells;
                
                return grid;
            } catch (error) {
                console.error('Grid extraction error:', error);
                return {
                    size: { rows: 0, cols: 0 },
                    cells: {},
                    status: 'error',
                    error: error.message
                };
            }
        }
        
        // Extract numbered cells from the grid
        function extractNumberedCells(gridStructure) {
            const numberedCells = [];
            
            for (const [cellId, cell] of Object.entries(gridStructure.cells)) {
                if (cell.type === 'numbered' && cell.number) {
                    numberedCells.push({
                        cellId: cellId,
                        number: cell.number,
                        row: parseInt(cellId.match(/R(\d+)/)[1]),
                        col: parseInt(cellId.match(/C(\d+)/)[1])
                    });
                }
            }
            
            // Sort by number
            numberedCells.sort((a, b) => a.number - b.number);
            
            console.log('Found numbered cells:', numberedCells);
            return numberedCells;
        }
        
        // Find lines that look like crossword grid rows
        function findGridLines(lines) {
            const gridLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Skip very short lines
                if (line.length < 5) continue;
                
                // Look for lines with grid-like patterns:
                // - Contains squares, blocks, or consistent spacing
                // - Has a reasonable length (typical crossword size)
                // - Contains characters that could represent grid cells
                
                // Check for patterns like: □□□■□□□ or similar
                const hasGridPattern = /[□■▢▣⬜⬛\s]{5,}/.test(line) || 
                                     /[\.\s]{5,}/.test(line) ||
                                     /[a-zA-Z\s]{5,}/.test(line);
                
                if (hasGridPattern && line.length >= 5 && line.length <= 20) {
                    gridLines.push({
                        line: line,
                        index: i,
                        length: line.length
                    });
                }
            }
            
            // Group consecutive lines of similar length
            const groupedLines = groupConsecutiveGridLines(gridLines);
            
            // Return the largest group (most likely to be the actual grid)
            return groupedLines.reduce((largest, group) => 
                group.length > largest.length ? group : largest, []);
        }
        
        // Group consecutive lines that could be part of the same grid
        function groupConsecutiveGridLines(gridLines) {
            if (gridLines.length === 0) return [];
            
            const groups = [];
            let currentGroup = [gridLines[0]];
            
            for (let i = 1; i < gridLines.length; i++) {
                const current = gridLines[i];
                const previous = gridLines[i - 1];
                
                // Check if lines are consecutive and similar length
                const isConsecutive = current.index === previous.index + 1;
                const isSimilarLength = Math.abs(current.length - previous.length) <= 2;
                
                if (isConsecutive && isSimilarLength) {
                    currentGroup.push(current);
                } else {
                    if (currentGroup.length > 0) {
                        groups.push(currentGroup);
                    }
                    currentGroup = [current];
                }
            }
            
            if (currentGroup.length > 0) {
                groups.push(currentGroup);
            }
            
            return groups;
        }
        
        // Parse the grid structure from grid lines
        function parseGridStructure(gridLines) {
            if (gridLines.length === 0) {
                return {
                    size: { rows: 0, cols: 0 },
                    cells: {},
                    status: 'no_grid_found'
                };
            }
            
            const rows = gridLines.length;
            const cols = Math.max(...gridLines.map(line => line.length));
            
            const cells = {};
            let cellId = 1;
            
            // Parse each cell in the grid
            for (let row = 0; row < rows; row++) {
                const line = gridLines[row].line;
                
                for (let col = 0; col < cols; col++) {
                    const cellChar = line[col] || ' ';
                    const cellIdStr = `R${row + 1}C${col + 1}`;
                    
                    // Determine cell type
                    let cellType = 'empty';
                    let cellNumber = null;
                    
                    if (cellChar === '■' || cellChar === '▣' || cellChar === '⬛') {
                        cellType = 'blocked';
                    } else if (cellChar === '□' || cellChar === '▢' || cellChar === '⬜' || cellChar === ' ') {
                        cellType = 'empty';
                    } else if (/[a-zA-Z]/.test(cellChar)) {
                        cellType = 'filled';
                    } else if (/\d/.test(cellChar)) {
                        cellType = 'numbered';
                        cellNumber = parseInt(cellChar);
                    }
                    
                    cells[cellIdStr] = {
                        type: cellType,
                        number: cellNumber,
                        content: cellChar
                    };
                }
            }
            
            console.log('Parsed grid:', { rows, cols, cells: Object.keys(cells).length });
            
            return {
                size: { rows, cols },
                cells: cells,
                status: 'success'
            };
        }
        
        // Helper function to validate if a clue is actually a valid crossword clue
        function isValidClue(clue) {
            const text = clue.text;
            
            console.log(`Validating clue: "${text}"`);
            
            // Skip if text is too short (less than 3 characters)
            if (text.length < 3) {
                console.log(`  - Too short: ${text.length} chars`);
                return false;
            }
            
            // Skip if text contains only numbers, symbols, or chess notation
            if (/^[0-9\s\.;:!τ\-]+$/.test(text)) {
                console.log(`  - Only symbols/numbers: ${text}`);
                return false;
            }
            
            // Skip if text contains chess notation patterns (τ, ;, !)
            if (text.includes('τ') || text.includes(';') || text.includes('!')) {
                console.log(`  - Contains chess notation: ${text}`);
                return false;
            }
            
            // Skip if text is mostly non-Hebrew characters
            const hebrewChars = text.match(/[א-ת]/g);
            if (!hebrewChars || hebrewChars.length < 2) {
                console.log(`  - Not enough Hebrew chars: ${hebrewChars ? hebrewChars.length : 0}`);
                return false;
            }
            
            // Skip if text looks like corrupted PDF content
            if (text.includes('τ') && text.length < 10) {
                console.log(`  - Corrupted PDF content: ${text}`);
                return false;
            }
            
            console.log(`  - Valid clue: ${text}`);
            return true;
        }

        // Display results in the table
        function displayResults(documentStructure) {
            console.log('displayResults function called with:', documentStructure);
            const tbody = document.querySelector('#results-table tbody');
            tbody.innerHTML = '';
            
            if (documentStructure.status === 'error') {
                const row = document.createElement('tr');
                row.innerHTML = `<td colspan="5">Error: ${documentStructure.error}</td>`;
                tbody.appendChild(row);
                return;
            }
            
            if (documentStructure.status === 'success') {
                console.log('=== DISPLAYING RESULTS ===');
                console.log('Horizontal clues:', documentStructure.clues.horizontal);
                console.log('Vertical clues:', documentStructure.clues.vertical);
                console.log('STATUS IS SUCCESS - PROCEEDING WITH VALIDATION');
                console.log('About to enter validation block...');
                
                // Get the numbered cells from the grid to filter clues
                console.log('STEP 1: Getting numbered cells...');
                const numberedCells = documentStructure.grid.numberedCells || [];
                let validClueNumbers = numberedCells.map(cell => cell.number);
                console.log('STEP 1 COMPLETE: numberedCells =', numberedCells);
                
                // Fallback: if no numbered cells found in grid, extract from clues themselves
                if (validClueNumbers.length === 0) {
                    console.log('No numbered cells found in grid, using clue numbers as fallback');
                    const allClueNumbers = [
                        ...documentStructure.clues.horizontal.map(clue => clue.number),
                        ...documentStructure.clues.vertical.map(clue => clue.number)
                    ];
                    validClueNumbers = [...new Set(allClueNumbers)].sort((a, b) => a - b);
                }
                
                console.log('Valid clue numbers from grid:', validClueNumbers);
                console.log('About to start validation...');
                
                // Test the validation function (removed to avoid confusion)

                // Filter clues to only show those that correspond to numbered cells AND are valid
                console.log('=== CLUE VALIDATION DEBUG ===');
                const validHorizontalClues = documentStructure.clues.horizontal.filter(clue => {
                    const isValid = validClueNumbers.includes(clue.number) && isValidClue(clue);
                    console.log(`Horizontal clue ${clue.number}: "${clue.text}" - Valid: ${isValid}`);
                    return isValid;
                });
                const validVerticalClues = documentStructure.clues.vertical.filter(clue => {
                    const isValid = validClueNumbers.includes(clue.number) && isValidClue(clue);
                    console.log(`Vertical clue ${clue.number}: "${clue.text}" - Valid: ${isValid}`);
                    return isValid;
                });

                console.log('Filtered horizontal clues:', validHorizontalClues);
                console.log('Filtered vertical clues:', validVerticalClues);

                // Filter out invalid clues before displaying
                const displayHorizontalClues = validHorizontalClues.filter(clue => {
                    const text = clue.text;
                    // Skip garbled content
                    if (text.includes('τ') || text.includes(';') || text.includes('!') ||
                        text.includes('צ:') || text.includes('ז5') || text.length < 5) {
                        console.log('Filtering out garbled clue:', text);
                        return false;
                    }
                    return true;
                });

                // Display filtered horizontal clues
                if (displayHorizontalClues.length > 0) {
                    displayHorizontalClues.forEach((clue, index) => {
                        const row = document.createElement('tr');
                        row.style.backgroundColor = index % 2 === 0 ? 'rgba(33, 150, 243, 0.05)' : 'transparent';
                        row.innerHTML = `
                            <td style="font-weight: bold; color: white;">${clue.number}</td>
                            <td style="font-weight: bold; color: white;">${clue.direction || 'H'}</td>
                            <td style="color: white;">TBD</td>
                            <td style="text-align: right; direction: rtl; color: white;">${clue.text}</td>
                            <td style="color: white;">${clue.answer || 'TBD'}</td>
                        `;
                        tbody.appendChild(row);
                    });
                }
                
                // Filter out invalid clues before displaying
                const displayVerticalClues = validVerticalClues.filter(clue => {
                    const text = clue.text;
                    // Skip garbled content
                    if (text.includes('τ') || text.includes(';') || text.includes('!') ||
                        text.includes('צ:') || text.includes('ז5') || text.length < 5) {
                        console.log('Filtering out garbled clue:', text);
                        return false;
                    }
                    return true;
                });

                // Display filtered vertical clues
                if (displayVerticalClues.length > 0) {
                    displayVerticalClues.forEach((clue, index) => {
                        const row = document.createElement('tr');
                        row.style.backgroundColor = index % 2 === 0 ? 'rgba(156, 39, 176, 0.05)' : 'transparent';
                        row.innerHTML = `
                            <td style="font-weight: bold; color: white;">${clue.number}</td>
                            <td style="font-weight: bold; color: white;">${clue.direction || 'V'}</td>
                            <td style="color: white;">TBD</td>
                            <td style="text-align: right; direction: rtl; color: white;">${clue.text}</td>
                            <td style="color: white;">${clue.answer || 'TBD'}</td>
                        `;
                        tbody.appendChild(row);
                    });
                }
                
                // Add summary row
                if (displayHorizontalClues.length === 0 && displayVerticalClues.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = '<td colspan="5" style="color: white;">No valid clues found. Check if the document contains אופקי/אנכי sections.</td>';
                    tbody.appendChild(row);
                } else {
                    const summaryRow = document.createElement('tr');
                    summaryRow.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                    summaryRow.style.border = '2px solid #4caf50';
                    
                    let gridInfo = '';
                    if (documentStructure.grid.status === 'success') {
                        const { rows, cols } = documentStructure.grid.size;
                        const cellCount = Object.keys(documentStructure.grid.cells).length;
                        const blockedCount = Object.values(documentStructure.grid.cells).filter(cell => cell.type === 'blocked').length;
                        const numberedCount = Object.values(documentStructure.grid.cells).filter(cell => cell.type === 'numbered').length;
                        
                        gridInfo = ` | Grid: ${rows}×${cols} (${cellCount} cells, ${blockedCount} blocked, ${numberedCount} numbered)`;
                        
                        // Show numbered cells if available
                        if (documentStructure.grid.numberedCells && documentStructure.grid.numberedCells.length > 0) {
                            const clueNumbers = documentStructure.grid.numberedCells.map(cell => cell.number).join(', ');
                            gridInfo += ` | Clue numbers: ${clueNumbers}`;
                        }
                    } else if (documentStructure.grid.status === 'no_grid_found') {
                        gridInfo = ' | No grid pattern found in answers document';
                    } else if (documentStructure.grid.status === 'error') {
                        gridInfo = ` | Grid parsing error: ${documentStructure.grid.error}`;
                    }
                    
                    summaryRow.innerHTML = `
                        <td colspan="5" style="text-align: center; font-weight: bold; color: white; padding: 15px;">
                            📊 EXTRACTION SUCCESS: ${displayHorizontalClues.length} horizontal clues, ${displayVerticalClues.length} vertical clues found${gridInfo}
                        </td>
                    `;
                    tbody.appendChild(summaryRow);
                }
            } else {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="5">Processing...</td>';
                tbody.appendChild(row);
            }
        }
    </script>
</body>
</html>
