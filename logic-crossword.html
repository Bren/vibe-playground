<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logic Crossword - drorbren.com</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.ico">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            padding: 2rem;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            text-align: center;
            padding: 0 20px;
        }
        
        h1 {
            font-size: 3rem;
            font-weight: 300;
            margin-bottom: 2rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .nav {
            margin-bottom: 3rem;
        }
        
        .nav a {
            color: white;
            text-decoration: none;
            margin: 0 1rem;
            padding: 0.5rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        .nav a:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .content {
            background: rgba(255, 255, 255, 0.1);
            padding: 2rem;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        p {
            font-size: 1.2rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }
        
        /* Upload Section Styles */
        .upload-section {
            margin-bottom: 3rem;
        }
        
        h2 {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            font-weight: 300;
        }
        
        .file-upload-container {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }
        
        .file-upload {
            flex: 1;
            min-width: 200px;
        }
        
        .file-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .file-label:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .file-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        
        .file-text {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .file-status {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            min-height: 1.2rem;
        }
        
        .file-status.uploaded {
            color: #4ade80;
        }
        
        .file-status.error {
            color: #f87171;
        }
        
        .extract-button {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .extract-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
        }
        
        .extract-button:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        /* Results Section Styles */
        .results-section {
            margin-top: 2rem;
        }
        
        .table-container {
            overflow-x: auto;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            margin: 20px 0;
            width: 100%;
        }
        
        .results-table {
            width: 100%;
            min-width: 1200px;
            border-collapse: collapse;
            background: transparent;
            table-layout: fixed;
        }
        
        .results-table th {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            text-align: left;
            font-weight: 500;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .results-table td {
            padding: 1.2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            vertical-align: top;
        }
        
        /* Column width constraints - wider layout for better readability */
        .results-table th:nth-child(1),
        .results-table td:nth-child(1) {
            width: 6%;
            text-align: center;
            min-width: 50px;
        }
        
        .results-table th:nth-child(2),
        .results-table td:nth-child(2) {
            width: 6%;
            text-align: center;
            min-width: 50px;
        }
        
        .results-table th:nth-child(3),
        .results-table td:nth-child(3) {
            width: 10%;
            text-align: center;
            min-width: 80px;
        }
        
        .results-table th:nth-child(4),
        .results-table td:nth-child(4) {
            width: 58%;
            word-break: break-word;
            white-space: normal;
            min-width: 400px;
        }
        
        .results-table th:nth-child(5),
        .results-table td:nth-child(5) {
            width: 20%;
            text-align: center;
            min-width: 150px;
        }
        
        .results-table tbody tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .nav a {
                display: block;
                margin: 0.5rem 0;
            }
            
            .file-upload-container {
                flex-direction: column;
                gap: 1rem;
            }
            
            .file-label {
                padding: 1.5rem;
            }
            
            .results-table th,
            .results-table td {
                padding: 0.5rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="index.html">Home</a>
            <a href="logic-crossword.html">Logic Crossword</a>
        </nav>
        
        <h1>Logic Crossword</h1>
        
        <div class="content">
            <div class="upload-section">
                <h2>Upload Files</h2>
                <div class="file-upload-container">
                    <div class="file-upload">
                        <label for="file1" class="file-label">
                            <span class="file-icon">üìÑ</span>
                            <span class="file-text">Add Clues File</span>
                            <input type="file" id="file1" accept=".txt,.pdf,.doc,.docx" style="display: none;">
                        </label>
                        <div id="file1-status" class="file-status"></div>
                    </div>
                    
                    <div class="file-upload">
                        <label for="file2" class="file-label">
                            <span class="file-icon">üìÑ</span>
                            <span class="file-text">Add Answers File</span>
                            <input type="file" id="file2" accept=".txt,.pdf,.doc,.docx" style="display: none;">
                        </label>
                        <div id="file2-status" class="file-status"></div>
                    </div>
                </div>
                
                <button id="extract-btn" class="extract-button" disabled>
                    Extract Clues and Answers
                </button>
            </div>
            
            <div style="margin-top: 20px; text-align: center;">
                <button onclick="clearCache()" style="background: #ff9800; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">
                    Clear Cache
                </button>
            </div>
            
            <div class="results-section">
                <h2>Results</h2>
                <div class="table-container">
                    <table id="results-table" class="results-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>H/V</th>
                                <th>Start Cell</th>
                                <th>Clue</th>
                                <th>Answer</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Results will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // File upload handling
        let uploadedFiles = { file1: null, file2: null };
        
        // Clear any cached data
        function clearCache() {
            uploadedFiles = { file1: null, file2: null };
            document.getElementById('results-table').querySelector('tbody').innerHTML = '';
            // Clear any global variables that might be holding data
            if (typeof window.lastDocumentStructure !== 'undefined') {
                delete window.lastDocumentStructure;
            }
            console.log('Cache cleared completely');
        }
        
        function updateExtractButton() {
            const extractBtn = document.getElementById('extract-btn');
            const bothFilesUploaded = uploadedFiles.file1 && uploadedFiles.file2;
            extractBtn.disabled = !bothFilesUploaded;
        }
        
        function handleFileUpload(fileInput, fileNumber) {
            const file = fileInput.files[0];
            const statusElement = document.getElementById(`file${fileNumber}-status`);
            
            if (file) {
                uploadedFiles[`file${fileNumber}`] = file;
                statusElement.textContent = `‚úÖ ${file.name} uploaded`;
                statusElement.className = 'file-status uploaded';
            } else {
                uploadedFiles[`file${fileNumber}`] = null;
                statusElement.textContent = '';
                statusElement.className = 'file-status';
            }
            
            updateExtractButton();
        }
        
        // Event listeners
        document.getElementById('file1').addEventListener('change', function() {
            handleFileUpload(this, 1);
        });
        
        document.getElementById('file2').addEventListener('change', function() {
            handleFileUpload(this, 2);
        });
        
        document.getElementById('extract-btn').addEventListener('click', function() {
            if (uploadedFiles.file1 && uploadedFiles.file2) {
                extractDocumentData(uploadedFiles.file1, uploadedFiles.file2);
            }
        });
        
        // Document extraction logic
        async function extractDocumentData(cluesFile, answersFile) {
            try {
                console.log('Starting extraction from:', cluesFile.name, 'and', answersFile.name);
                
                // Extract text from both files
                const cluesText = await extractTextFromFile(cluesFile);
                const answersText = await extractTextFromFile(answersFile);
                
                console.log('=== EXTRACTION RESULTS ===');
                console.log('Clues file:', cluesFile.name);
                console.log('Answers file:', answersFile.name);
                console.log('Clues text length:', cluesText.length);
                console.log('Answers text length:', answersText.length);
                console.log('Clues text preview:', cluesText.substring(0, 500));
                console.log('Answers text preview:', answersText.substring(0, 500));
                
                // Parse document structure
                const documentStructure = parseDocumentStructure(cluesText, answersText);
                
                console.log('Document structure:', documentStructure);
                
                // Display results in table
                displayResults(documentStructure);
                
            } catch (error) {
                console.error('Extraction failed:', error);
                alert('Extraction failed: ' + error.message);
            }
        }
        
        // Extract text from file (PDF or text)
        async function extractTextFromFile(file) {
            return new Promise((resolve, reject) => {
                if (file.type === 'application/pdf') {
                    // Handle PDF files with PDF.js
                    const reader = new FileReader();
                    
                    reader.onload = async function(e) {
                        try {
                            const arrayBuffer = e.target.result;
                            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                            let fullText = '';
                            
                            // Extract text from all pages
                            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                                const page = await pdf.getPage(pageNum);
                                const textContent = await page.getTextContent();
                                const pageText = textContent.items.map(item => item.str).join(' ');
                                fullText += pageText + '\n';
                            }
                            
                            resolve(fullText);
                        } catch (error) {
                            reject(new Error('Failed to parse PDF: ' + error.message));
                        }
                    };
                    
                    reader.onerror = function() {
                        reject(new Error('Failed to read PDF file'));
                    };
                    
                    reader.readAsArrayBuffer(file);
                } else {
                    // Handle text files
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        resolve(e.target.result);
                    };
                    
                    reader.onerror = function() {
                        reject(new Error('Failed to read text file'));
                    };
                    
                    reader.readAsText(file);
                }
            });
        }
        
        // Parse document structure
        function parseDocumentStructure(cluesText, answersText) {
            try {
                // Extract clues from the clues document
                const clues = extractClues(cluesText);
                
                // Extract answers from the answers document
                const answers = extractAnswers(answersText);
                
                // Match clues with answers
                const matchedClues = matchCluesWithAnswers(clues, answers);
                
                // Extract grid from the answers document
                const grid = extractGrid(answersText);
                
                return {
                    clues: matchedClues,
                    answers: answers,
                    grid: grid,
                    status: 'success'
                };
            } catch (error) {
                console.error('Parsing error:', error);
                return {
                    clues: { horizontal: [], vertical: [] },
                    grid: { size: { rows: 0, cols: 0 }, cells: {} },
                    status: 'error',
                    error: error.message
                };
            }
        }
        
        // Extract answers from the solution section (◊§◊™◊®◊ï◊ü ◊™◊©◊ë◊• ◊î◊í◊ô◊ï◊ü) - FINAL VERSION
        function extractAnswers(text) {
            console.log('=== FINAL ANSWER EXTRACTION ===');
            
            // Step 1: Find the solution section
            const solutionIndex = text.indexOf('◊§◊™◊®◊ï◊ü ◊™◊©◊ë◊• ◊î◊í◊ô◊ï◊ü ◊û◊°\' 1724');
            if (solutionIndex === -1) {
                console.log('‚ùå No solution section found');
                return { horizontal: [], vertical: [] };
            }
            
            // Step 2: Extract the solution section
            const solutionSection = text.substring(solutionIndex);
            console.log('üîç DEBUG - Solution section found at index:', solutionIndex);
            
            // Step 3: Find ◊û◊ê◊ï◊†◊ö: (this is the key separator)
            const ◊û◊ê◊ï◊†◊öIndex = solutionSection.indexOf('◊û◊ê◊ï◊†◊ö:');
            if (◊û◊ê◊ï◊†◊öIndex === -1) {
                console.log('‚ùå Could not find ◊û◊ê◊ï◊†◊ö section');
                return { horizontal: [], vertical: [] };
            }
            
            // Step 4: Extract horizontal answers (everything before ◊û◊ê◊ï◊†◊ö:)
            const horizontalText = solutionSection.substring(0, ◊û◊ê◊ï◊†◊öIndex).trim();
            let verticalText = solutionSection.substring(◊û◊ê◊ï◊†◊öIndex + 6).trim();
            
            // Step 4.1: Find the actual start of vertical answers
            // Look for the first "1. " pattern in the vertical section
            const verticalStartIndex = verticalText.indexOf('1. ');
            if (verticalStartIndex > 0) {
                verticalText = verticalText.substring(verticalStartIndex);
            }
            
            // Step 4.2: Look for the actual start of vertical answers
            // The vertical section is getting cut off at the beginning
            // Let's look for the pattern that should be there
            const verticalStartPatterns = ['1. ◊ë◊†◊ì◊†◊î', '3. ◊ú◊¢◊ë◊®◊ô', '14. ◊î◊ï◊û◊ï ◊§◊ë◊®', '12. ◊ë◊®◊ï◊ö'];
            let bestStartIndex = -1;
            let bestPattern = '';
            
            for (const pattern of verticalStartPatterns) {
                const index = verticalText.indexOf(pattern);
                if (index > 0 && (bestStartIndex === -1 || index < bestStartIndex)) {
                    bestStartIndex = index;
                    bestPattern = pattern;
                }
            }
            
            if (bestStartIndex > 0) {
                verticalText = verticalText.substring(bestStartIndex);
                console.log(`üîç DEBUG - Found vertical start with pattern: ${bestPattern}`);
            } else {
                // If no pattern found, try to find the start by looking for the first number pattern
                const numberPattern = verticalText.match(/\d+\.\s*[◊ê-◊™]/);
                if (numberPattern) {
                    const startIndex = verticalText.indexOf(numberPattern[0]);
                    if (startIndex > 0) {
                        verticalText = verticalText.substring(startIndex);
                        console.log(`üîç DEBUG - Found vertical start with number pattern: ${numberPattern[0]}`);
                    }
                }
            }
            
            // Step 4.5: Clean up horizontal text to remove vertical answers that got mixed in
            // The horizontal section should end before the vertical answers start
            const horizontalEndIndex = horizontalText.lastIndexOf('26. ◊¢◊ú ◊î◊§◊™◊ó◊ô◊ù');
            const cleanHorizontalText = horizontalEndIndex > 0 ? 
                horizontalText.substring(0, horizontalEndIndex + '26. ◊¢◊ú ◊î◊§◊™◊ó◊ô◊ù'.length) : 
                horizontalText;
            
            // Step 4.6: Extract vertical answers from the horizontal section (they got mixed in)
            // Look for vertical answers that are in the horizontal section
            const verticalAnswersInHorizontal = horizontalText.substring(horizontalEndIndex + '26. ◊¢◊ú ◊î◊§◊™◊ó◊ô◊ù'.length);
            const verticalAnswersFromHorizontal = verticalAnswersInHorizontal.trim();
            
            console.log('üîç DEBUG - ◊û◊ê◊ï◊†◊öIndex:', ◊û◊ê◊ï◊†◊öIndex);
            console.log('üîç DEBUG - Horizontal section:', horizontalText);
            console.log('üîç DEBUG - Clean horizontal section:', cleanHorizontalText);
            console.log('üîç DEBUG - Vertical answers from horizontal:', verticalAnswersFromHorizontal);
            console.log('üîç DEBUG - Vertical section (raw):', solutionSection.substring(◊û◊ê◊ï◊†◊öIndex + 6).trim());
            console.log('üîç DEBUG - Vertical section (cleaned):', verticalText);
            
            // Step 5: Parse answers
            const horizontalAnswers = parseSimpleAnswers(cleanHorizontalText, 'H');
            const verticalAnswersFromHorizontalParsed = parseSimpleAnswers(verticalAnswersFromHorizontal, 'V');
            const verticalAnswersFromSectionParsed = parseSimpleAnswers(verticalText, 'V');
            
            // Combine vertical answers from both sources
            const verticalAnswers = [...verticalAnswersFromHorizontalParsed, ...verticalAnswersFromSectionParsed];
            
            console.log(`üìä Extracted ${horizontalAnswers.length} horizontal + ${verticalAnswers.length} vertical answers`);
            console.log(`üìä Vertical from horizontal: ${verticalAnswersFromHorizontalParsed.length}, from section: ${verticalAnswersFromSectionParsed.length}`);
            
            return {
                horizontal: horizontalAnswers,
                vertical: verticalAnswers
            };
        }
        
        // Parse answers in format: "1. ◊ë◊ï◊ò◊§◊ú◊ô◊ß◊î 5. ◊†◊°◊§◊î 9. ◊ì◊ï ◊ß◊®◊ë 10. ◊ì◊®◊ö ◊î◊û◊ú◊ö"
        function parseSimpleAnswers(text, direction) {
            const answers = [];
            
            console.log(`Parsing ${direction} answers from:`, text);
            
            // Remove the section header (◊û◊ê◊ï◊ñ◊ü: or ◊û◊ê◊ï◊†◊ö:)
            let cleanText = text.replace(/^[^◊ê-◊™]*/, '').trim();
            
            // Find all number.answer patterns
            const matches = cleanText.match(/(\d+)\.\s*([◊ê-◊™][^]*?)(?=\s+\d+\.|$)/g);
            
            if (matches) {
                matches.forEach(match => {
                    const parts = match.match(/^(\d+)\.\s*(.*)$/);
                    if (parts) {
                        const number = parseInt(parts[1]);
                        let answerText = parts[2].trim();
                        
                        // Clean up trailing period and extra text
                        answerText = answerText.replace(/\.$/, '').trim();
                        
                        // Only keep Hebrew text, stop at non-Hebrew characters
                        const hebrewMatch = answerText.match(/^[◊ê-◊™\s\(\)]+/);
                        if (hebrewMatch) {
                            answerText = hebrewMatch[0].trim();
                        }
                        
                        if (answerText && /[◊ê-◊™]/.test(answerText)) {
                            answers.push({
                                number: number,
                                text: answerText,
                                direction: direction
                            });
                            console.log(`  üìù ${number}${direction}: ${answerText}`);
                        }
                    }
                });
            }
            
            return answers;
        }
        
        // Clean up and simplify the matching function
        function matchCluesWithAnswers(clues, answers) {
            console.log('=== SIMPLE MATCHING ===');
            
            // Create answer lookup maps
            const horizontalAnswerMap = new Map();
            const verticalAnswerMap = new Map();
            
            answers.horizontal.forEach(answer => {
                horizontalAnswerMap.set(answer.number, answer.text);
                console.log(`üìù H${answer.number}: ${answer.text}`);
            });
            
            answers.vertical.forEach(answer => {
                verticalAnswerMap.set(answer.number, answer.text);
                console.log(`üìù V${answer.number}: ${answer.text}`);
            });
            
            // Match clues with answers
            const matchedHorizontal = clues.horizontal.map(clue => ({
                ...clue,
                answer: horizontalAnswerMap.get(clue.number) || 'TBD'
            }));
            
            const matchedVertical = clues.vertical.map(clue => ({
                ...clue,
                answer: verticalAnswerMap.get(clue.number) || 'TBD'
            }));
            
            console.log(`üéØ Matched ${matchedHorizontal.length}H + ${matchedVertical.length}V clues`);
            
            return {
                horizontal: matchedHorizontal,
                vertical: matchedVertical
            };
        }
        
        // Extract clues from text - CLEAN VERSION
        function extractClues(text) {
            console.log('=== CLEAN CLUE EXTRACTION ===');
            
            // Step 1: Find horizontal and vertical sections
            const horizontalMatch = text.match(/◊û◊ê◊ï◊ñ◊ü:\s*(.*?)(?=◊û◊ê◊ï◊†◊ö:|◊§◊™◊®◊ï◊ü|$)/s);
            const verticalMatch = text.match(/◊û◊ê◊ï◊†◊ö:\s*(.*?)(?=◊§◊™◊®◊ï◊ü|$)/s);
            
            const horizontalClues = horizontalMatch ? parseSimpleClues(horizontalMatch[1].trim(), 'H') : [];
            const verticalClues = verticalMatch ? parseSimpleClues(verticalMatch[1].trim(), 'V') : [];
            
            console.log(`üìä Extracted ${horizontalClues.length} horizontal + ${verticalClues.length} vertical clues`);
            
            return {
                horizontal: horizontalClues,
                vertical: verticalClues
            };
        }
        
        // Parse clues in simple format: "14. ◊î◊ú◊ï◊®◊ì ◊†◊ë◊ó◊ü (3,3); 16. text (4);"
        function parseSimpleClues(text, direction) {
            const clues = [];
            
            // Split by semicolon and number pattern
            const parts = text.split(';');
            
            parts.forEach(part => {
                part = part.trim();
                if (!part) return;
                
                const match = part.match(/^(\d+)\.\s*(.+)$/);
                if (match) {
                    const number = parseInt(match[1]);
                    const clueText = match[2].trim();
                    
                    if (clueText && clueText.length > 3) {
                        clues.push({
                            number: number,
                            direction: direction,
                            text: clueText,
                            type: direction === 'H' ? 'horizontal' : 'vertical'
                        });
                        console.log(`  üß© ${number}${direction}: ${clueText}`);
                    }
                }
            });
            
            return clues;
        }
        
        // Extract grid from text
        function extractGrid(text) {
            try {
                // Look for grid patterns in the text
                const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                
                // Find potential grid lines (lines with consistent character patterns)
                const gridLines = findGridLines(lines);
                
                if (gridLines.length === 0) {
                    return {
                        size: { rows: 0, cols: 0 },
                        cells: {},
                        status: 'no_grid_found'
                    };
                }
                
                // Parse the grid structure
                const grid = parseGridStructure(gridLines);
                
                // Extract numbered cells to identify clue numbers
                const numberedCells = extractNumberedCells(grid);
                grid.numberedCells = numberedCells;
                
                return grid;
            } catch (error) {
                console.error('Grid extraction error:', error);
                return {
                    size: { rows: 0, cols: 0 },
                    cells: {},
                    status: 'error',
                    error: error.message
                };
            }
        }
        
        // Extract numbered cells from the grid
        function extractNumberedCells(gridStructure) {
            const numberedCells = [];
            
            for (const [cellId, cell] of Object.entries(gridStructure.cells)) {
                if (cell.type === 'numbered' && cell.number) {
                    numberedCells.push({
                        cellId: cellId,
                        number: cell.number,
                        row: parseInt(cellId.match(/R(\d+)/)[1]),
                        col: parseInt(cellId.match(/C(\d+)/)[1])
                    });
                }
            }
            
            // Sort by number
            numberedCells.sort((a, b) => a.number - b.number);
            
            console.log('Found numbered cells:', numberedCells);
            return numberedCells;
        }
        
        // Find lines that look like crossword grid rows
        function findGridLines(lines) {
            const gridLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Skip very short lines
                if (line.length < 5) continue;
                
                // Look for lines with grid-like patterns:
                // - Contains squares, blocks, or consistent spacing
                // - Has a reasonable length (typical crossword size)
                // - Contains characters that could represent grid cells
                
                // Check for patterns like: ‚ñ°‚ñ°‚ñ°‚ñ†‚ñ°‚ñ°‚ñ° or similar
                const hasGridPattern = /[‚ñ°‚ñ†‚ñ¢‚ñ£‚¨ú‚¨õ\s]{5,}/.test(line) || 
                                     /[\.\s]{5,}/.test(line) ||
                                     /[a-zA-Z\s]{5,}/.test(line);
                
                if (hasGridPattern && line.length >= 5 && line.length <= 20) {
                    gridLines.push({
                        line: line,
                        index: i,
                        length: line.length
                    });
                }
            }
            
            // Group consecutive lines of similar length
            const groupedLines = groupConsecutiveGridLines(gridLines);
            
            // Return the largest group (most likely to be the actual grid)
            return groupedLines.reduce((largest, group) => 
                group.length > largest.length ? group : largest, []);
        }
        
        // Group consecutive lines that could be part of the same grid
        function groupConsecutiveGridLines(gridLines) {
            if (gridLines.length === 0) return [];
            
            const groups = [];
            let currentGroup = [gridLines[0]];
            
            for (let i = 1; i < gridLines.length; i++) {
                const current = gridLines[i];
                const previous = gridLines[i - 1];
                
                // Check if lines are consecutive and similar length
                const isConsecutive = current.index === previous.index + 1;
                const isSimilarLength = Math.abs(current.length - previous.length) <= 2;
                
                if (isConsecutive && isSimilarLength) {
                    currentGroup.push(current);
                } else {
                    if (currentGroup.length > 0) {
                        groups.push(currentGroup);
                    }
                    currentGroup = [current];
                }
            }
            
            if (currentGroup.length > 0) {
                groups.push(currentGroup);
            }
            
            return groups;
        }
        
        // Parse the grid structure from grid lines
        function parseGridStructure(gridLines) {
            if (gridLines.length === 0) {
                return {
                    size: { rows: 0, cols: 0 },
                    cells: {},
                    status: 'no_grid_found'
                };
            }
            
            const rows = gridLines.length;
            const cols = Math.max(...gridLines.map(line => line.length));
            
            const cells = {};
            let cellId = 1;
            
            // Parse each cell in the grid
            for (let row = 0; row < rows; row++) {
                const line = gridLines[row].line;
                
                for (let col = 0; col < cols; col++) {
                    const cellChar = line[col] || ' ';
                    const cellIdStr = `R${row + 1}C${col + 1}`;
                    
                    // Determine cell type
                    let cellType = 'empty';
                    let cellNumber = null;
                    
                    if (cellChar === '‚ñ†' || cellChar === '‚ñ£' || cellChar === '‚¨õ') {
                        cellType = 'blocked';
                    } else if (cellChar === '‚ñ°' || cellChar === '‚ñ¢' || cellChar === '‚¨ú' || cellChar === ' ') {
                        cellType = 'empty';
                    } else if (/[a-zA-Z]/.test(cellChar)) {
                        cellType = 'filled';
                    } else if (/\d/.test(cellChar)) {
                        cellType = 'numbered';
                        cellNumber = parseInt(cellChar);
                    }
                    
                    cells[cellIdStr] = {
                        type: cellType,
                        number: cellNumber,
                        content: cellChar
                    };
                }
            }
            
            console.log('Parsed grid:', { rows, cols, cells: Object.keys(cells).length });
            
            return {
                size: { rows, cols },
                cells: cells,
                status: 'success'
            };
        }
        
        // Helper function to validate if a clue is actually a valid crossword clue
        function isValidClue(clue) {
            const text = clue.text;
            
            console.log(`Validating clue: "${text}"`);
            
            // Skip if text is too short (less than 3 characters)
            if (text.length < 3) {
                console.log(`  - Too short: ${text.length} chars`);
                return false;
            }
            
            // Skip if text contains only numbers, symbols, or chess notation
            if (/^[0-9\s\.;:!œÑ\-]+$/.test(text)) {
                console.log(`  - Only symbols/numbers: ${text}`);
                return false;
            }
            
            // Skip if text contains chess notation patterns (œÑ, ;, !)
            if (text.includes('œÑ') || text.includes(';') || text.includes('!')) {
                console.log(`  - Contains chess notation: ${text}`);
                return false;
            }
            
            // Skip if text is mostly non-Hebrew characters
            const hebrewChars = text.match(/[◊ê-◊™]/g);
            if (!hebrewChars || hebrewChars.length < 2) {
                console.log(`  - Not enough Hebrew chars: ${hebrewChars ? hebrewChars.length : 0}`);
                return false;
            }
            
            // Skip if text looks like corrupted PDF content
            if (text.includes('œÑ') && text.length < 10) {
                console.log(`  - Corrupted PDF content: ${text}`);
                return false;
            }
            
            console.log(`  - Valid clue: ${text}`);
            return true;
        }

        // Display results in the table
        function displayResults(documentStructure) {
            console.log('displayResults function called with:', documentStructure);
            const tbody = document.querySelector('#results-table tbody');
            tbody.innerHTML = '';
            
            if (documentStructure.status === 'error') {
                const row = document.createElement('tr');
                row.innerHTML = `<td colspan="5">Error: ${documentStructure.error}</td>`;
                tbody.appendChild(row);
                return;
            }
            
            if (documentStructure.status === 'success') {
                console.log('=== DISPLAYING RESULTS ===');
                console.log('Horizontal clues:', documentStructure.clues.horizontal);
                console.log('Vertical clues:', documentStructure.clues.vertical);
                console.log('STATUS IS SUCCESS - PROCEEDING WITH VALIDATION');
                console.log('About to enter validation block...');
                
                // Get the numbered cells from the grid to filter clues
                console.log('STEP 1: Getting numbered cells...');
                const numberedCells = documentStructure.grid.numberedCells || [];
                let validClueNumbers = numberedCells.map(cell => cell.number);
                console.log('STEP 1 COMPLETE: numberedCells =', numberedCells);
                
                // Fallback: if no numbered cells found in grid, extract from clues themselves
                if (validClueNumbers.length === 0) {
                    console.log('No numbered cells found in grid, using clue numbers as fallback');
                    const allClueNumbers = [
                        ...documentStructure.clues.horizontal.map(clue => clue.number),
                        ...documentStructure.clues.vertical.map(clue => clue.number)
                    ];
                    validClueNumbers = [...new Set(allClueNumbers)].sort((a, b) => a - b);
                }
                
                console.log('Valid clue numbers from grid:', validClueNumbers);
                console.log('About to start validation...');
                
                // Test the validation function (removed to avoid confusion)

                // Filter clues to only show those that correspond to numbered cells AND are valid
                console.log('=== CLUE VALIDATION DEBUG ===');
                const validHorizontalClues = documentStructure.clues.horizontal.filter(clue => {
                    const isValid = validClueNumbers.includes(clue.number) && isValidClue(clue);
                    console.log(`Horizontal clue ${clue.number}: "${clue.text}" - Valid: ${isValid}`);
                    return isValid;
                });
                const validVerticalClues = documentStructure.clues.vertical.filter(clue => {
                    const isValid = validClueNumbers.includes(clue.number) && isValidClue(clue);
                    console.log(`Vertical clue ${clue.number}: "${clue.text}" - Valid: ${isValid}`);
                    return isValid;
                });

                console.log('Filtered horizontal clues:', validHorizontalClues);
                console.log('Filtered vertical clues:', validVerticalClues);

                // Filter out invalid clues before displaying
                const displayHorizontalClues = validHorizontalClues.filter(clue => {
                    const text = clue.text;
                    // Skip garbled content
                    if (text.includes('œÑ') || text.includes(';') || text.includes('!') ||
                        text.includes('◊¶:') || text.includes('◊ñ5') || text.length < 5) {
                        console.log('Filtering out garbled clue:', text);
                        return false;
                    }
                    return true;
                });

                // Display filtered horizontal clues
                if (displayHorizontalClues.length > 0) {
                    displayHorizontalClues.forEach((clue, index) => {
                        const row = document.createElement('tr');
                        row.style.backgroundColor = index % 2 === 0 ? 'rgba(33, 150, 243, 0.05)' : 'transparent';
                        row.innerHTML = `
                            <td style="font-weight: bold; color: white;">${clue.number}</td>
                            <td style="font-weight: bold; color: white;">${clue.direction || 'H'}</td>
                            <td style="color: white;">TBD</td>
                            <td style="text-align: right; direction: rtl; color: white;">${clue.text}</td>
                            <td style="color: white;">${clue.answer || 'TBD'}</td>
                        `;
                        tbody.appendChild(row);
                    });
                }
                
                // Filter out invalid clues before displaying
                const displayVerticalClues = validVerticalClues.filter(clue => {
                    const text = clue.text;
                    // Skip garbled content
                    if (text.includes('œÑ') || text.includes(';') || text.includes('!') ||
                        text.includes('◊¶:') || text.includes('◊ñ5') || text.length < 5) {
                        console.log('Filtering out garbled clue:', text);
                        return false;
                    }
                    return true;
                });

                // Display filtered vertical clues
                if (displayVerticalClues.length > 0) {
                    displayVerticalClues.forEach((clue, index) => {
                        const row = document.createElement('tr');
                        row.style.backgroundColor = index % 2 === 0 ? 'rgba(156, 39, 176, 0.05)' : 'transparent';
                        row.innerHTML = `
                            <td style="font-weight: bold; color: white;">${clue.number}</td>
                            <td style="font-weight: bold; color: white;">${clue.direction || 'V'}</td>
                            <td style="color: white;">TBD</td>
                            <td style="text-align: right; direction: rtl; color: white;">${clue.text}</td>
                            <td style="color: white;">${clue.answer || 'TBD'}</td>
                        `;
                        tbody.appendChild(row);
                    });
                }
                
                // Add summary row
                if (displayHorizontalClues.length === 0 && displayVerticalClues.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = '<td colspan="5" style="color: white;">No valid clues found. Check if the document contains ◊ê◊ï◊§◊ß◊ô/◊ê◊†◊õ◊ô sections.</td>';
                    tbody.appendChild(row);
                } else {
                    const summaryRow = document.createElement('tr');
                    summaryRow.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                    summaryRow.style.border = '2px solid #4caf50';
                    
                    let gridInfo = '';
                    if (documentStructure.grid.status === 'success') {
                        const { rows, cols } = documentStructure.grid.size;
                        const cellCount = Object.keys(documentStructure.grid.cells).length;
                        const blockedCount = Object.values(documentStructure.grid.cells).filter(cell => cell.type === 'blocked').length;
                        const numberedCount = Object.values(documentStructure.grid.cells).filter(cell => cell.type === 'numbered').length;
                        
                        gridInfo = ` | Grid: ${rows}√ó${cols} (${cellCount} cells, ${blockedCount} blocked, ${numberedCount} numbered)`;
                        
                        // Show numbered cells if available
                        if (documentStructure.grid.numberedCells && documentStructure.grid.numberedCells.length > 0) {
                            const clueNumbers = documentStructure.grid.numberedCells.map(cell => cell.number).join(', ');
                            gridInfo += ` | Clue numbers: ${clueNumbers}`;
                        }
                    } else if (documentStructure.grid.status === 'no_grid_found') {
                        gridInfo = ' | No grid pattern found in answers document';
                    } else if (documentStructure.grid.status === 'error') {
                        gridInfo = ` | Grid parsing error: ${documentStructure.grid.error}`;
                    }
                    
                    summaryRow.innerHTML = `
                        <td colspan="5" style="text-align: center; font-weight: bold; color: white; padding: 15px;">
                            üìä EXTRACTION SUCCESS: ${displayHorizontalClues.length} horizontal clues, ${displayVerticalClues.length} vertical clues found${gridInfo}
                        </td>
                    `;
                    tbody.appendChild(summaryRow);
                }
            } else {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="5">Processing...</td>';
                tbody.appendChild(row);
            }
        }
    </script>
</body>
</html>

