<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logic Crossword - drorbren.com</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.ico">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            padding: 2rem;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            text-align: center;
            padding: 0 20px;
        }
        
        h1 {
            font-size: 3rem;
            font-weight: 300;
            margin-bottom: 2rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .nav {
            margin-bottom: 3rem;
        }
        
        .nav a {
            color: white;
            text-decoration: none;
            margin: 0 1rem;
            padding: 0.5rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        .nav a:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .content {
            background: rgba(255, 255, 255, 0.1);
            padding: 2rem;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        p {
            font-size: 1.2rem;
            line-height: 1.6;
            margin-bottom: 1rem;
        }
        
        /* Upload Section Styles */
        .upload-section {
            margin-bottom: 3rem;
        }
        
        h2 {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            font-weight: 300;
        }
        
        .file-upload-container {
            display: flex;
            gap: 2rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }
        
        .file-upload {
            flex: 1;
            min-width: 200px;
        }
        
        .file-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .file-label:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .file-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        
        .file-text {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .file-status {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            min-height: 1.2rem;
        }
        
        .file-status.uploaded {
            color: #4ade80;
        }
        
        .file-status.error {
            color: #f87171;
        }
        
        .extract-button {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: white;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .extract-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 222, 128, 0.3);
        }
        
        .extract-button:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        /* Results Section Styles */
        .results-section {
            margin-top: 2rem;
        }
        
        .table-container {
            overflow-x: auto;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
            margin: 20px 0;
            width: 100%;
        }
        
        .results-table {
            width: 100%;
            min-width: 1200px;
            border-collapse: collapse;
            background: transparent;
            table-layout: fixed;
        }
        
        .results-table th {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            text-align: left;
            font-weight: 500;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .results-table td {
            padding: 1.2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            vertical-align: top;
        }
        
        /* Column width constraints - wider layout for better readability */
        .results-table th:nth-child(1),
        .results-table td:nth-child(1) {
            width: 6%;
            text-align: center;
            min-width: 50px;
        }
        
        .results-table th:nth-child(2),
        .results-table td:nth-child(2) {
            width: 6%;
            text-align: center;
            min-width: 50px;
        }
        
        .results-table th:nth-child(3),
        .results-table td:nth-child(3) {
            width: 10%;
            text-align: center;
            min-width: 80px;
        }
        
        .results-table th:nth-child(4),
        .results-table td:nth-child(4) {
            width: 58%;
            word-break: break-word;
            white-space: normal;
            min-width: 400px;
        }
        
        .results-table th:nth-child(5),
        .results-table td:nth-child(5) {
            width: 20%;
            text-align: center;
            min-width: 150px;
        }
        
        .results-table tbody tr:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
            }
            
            .nav a {
                display: block;
                margin: 0.5rem 0;
            }
            
            .file-upload-container {
                flex-direction: column;
                gap: 1rem;
            }
            
            .file-label {
                padding: 1.5rem;
            }
            
            .results-table th,
            .results-table td {
                padding: 0.5rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <nav class="nav">
            <a href="index.html">Home</a>
            <a href="logic-crossword.html">Logic Crossword</a>
            <a href="pixel-options.html">Pixel Options</a>
        </nav>
        
        <h1>Logic Crossword</h1>
        
        <div class="content">
            <div class="upload-section">
                <h2>Upload Files</h2>
                <div class="file-upload-container">
                    <div class="file-upload">
                        <label for="file1" class="file-label">
                            <span class="file-icon">ðŸ“„</span>
                            <span class="file-text">Add Clues File</span>
                            <input type="file" id="file1" accept=".txt,.pdf,.doc,.docx" style="display: none;">
                        </label>
                        <div id="file1-status" class="file-status"></div>
                    </div>
                    
                    <div class="file-upload">
                        <label for="file2" class="file-label">
                            <span class="file-icon">ðŸ“„</span>
                            <span class="file-text">Add Answers File</span>
                            <input type="file" id="file2" accept=".txt,.pdf,.doc,.docx" style="display: none;">
                        </label>
                        <div id="file2-status" class="file-status"></div>
                    </div>
                </div>
                
                <button id="extract-btn" class="extract-button" disabled>
                    Extract Clues and Answers
                </button>
            </div>
            
            
            <div class="results-section">
                <h2>Results</h2>
                <div style="margin-bottom: 1rem;">
                    <button id="export-csv-btn" class="btn" style="display: none; background: #4caf50; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 5px; cursor: pointer; font-size: 1rem; transition: all 0.3s ease;" onmouseover="this.style.background='#45a049'" onmouseout="this.style.background='#4caf50'" onclick="exportToCSV()">
                        ðŸ“Š Export to CSV
                    </button>
                </div>
                <div class="table-container">
                    <table id="results-table" class="results-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>H/V</th>
                                <th>Clue</th>
                                <th>Answer</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Results will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // File upload handling
        let uploadedFiles = { file1: null, file2: null };
        
        // Clear any cached data
        function clearCache() {
            uploadedFiles = { file1: null, file2: null };
            document.getElementById('results-table').querySelector('tbody').innerHTML = '';
            // Clear any global variables that might be holding data
            if (typeof window.lastDocumentStructure !== 'undefined') {
                delete window.lastDocumentStructure;
            }
            // Hide export button
            document.getElementById('export-csv-btn').style.display = 'none';
            console.log('Cache cleared completely');
        }

        // Export data to CSV
        function exportToCSV() {
            if (!window.lastDocumentStructure || window.lastDocumentStructure.status !== 'success') {
                alert('No data to export. Please extract crossword data first.');
                return;
            }

            const documentStructure = window.lastDocumentStructure;
            const csvData = [];
            
            // Add header row
            csvData.push(['Number', 'Direction', 'Clue', 'Answer']);
            
            // Add horizontal clues
            if (documentStructure.clues.horizontal) {
                documentStructure.clues.horizontal.forEach(clue => {
                    if (clue.text && clue.text.length > 5 && !clue.text.includes('Ï„') && !clue.text.includes(';')) {
                        csvData.push([clue.number, 'H', clue.text, clue.answer || '']);
                    }
                });
            }
            
            // Add vertical clues
            if (documentStructure.clues.vertical) {
                documentStructure.clues.vertical.forEach(clue => {
                    if (clue.text && clue.text.length > 5 && !clue.text.includes('Ï„') && !clue.text.includes(';')) {
                        csvData.push([clue.number, 'V', clue.text, clue.answer || '']);
                    }
                });
            }
            
            // Convert to CSV string
            const csvContent = csvData.map(row => 
                row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
            ).join('\n');
            
            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            
            // Generate filename with timestamp
            const now = new Date();
            const timestamp = now.toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `crossword-export-${timestamp}.csv`;
            link.setAttribute('download', filename);
            
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log(`CSV exported: ${filename} with ${csvData.length - 1} entries`);
        }
        
        function updateExtractButton() {
            const extractBtn = document.getElementById('extract-btn');
            const bothFilesUploaded = uploadedFiles.file1 && uploadedFiles.file2;
            extractBtn.disabled = !bothFilesUploaded;
        }
        
        function handleFileUpload(fileInput, fileNumber) {
            const file = fileInput.files[0];
            const statusElement = document.getElementById(`file${fileNumber}-status`);
            
            if (file) {
                uploadedFiles[`file${fileNumber}`] = file;
                statusElement.textContent = `âœ… ${file.name} uploaded`;
                statusElement.className = 'file-status uploaded';
            } else {
                uploadedFiles[`file${fileNumber}`] = null;
                statusElement.textContent = '';
                statusElement.className = 'file-status';
            }
            
            updateExtractButton();
        }
        
        // Event listeners
        document.getElementById('file1').addEventListener('change', function() {
            handleFileUpload(this, 1);
        });
        
        document.getElementById('file2').addEventListener('change', function() {
            handleFileUpload(this, 2);
        });
        
        document.getElementById('extract-btn').addEventListener('click', function() {
            if (uploadedFiles.file1 && uploadedFiles.file2) {
                extractDocumentData(uploadedFiles.file1, uploadedFiles.file2);
            }
        });
        
        // Document extraction logic
        async function extractDocumentData(cluesFile, answersFile) {
            try {
                console.log('Starting extraction from:', cluesFile.name, 'and', answersFile.name);
                
                // Extract text from both files
                const cluesText = await extractTextFromFile(cluesFile);
                const answersText = await extractTextFromFile(answersFile);
                
                console.log('=== EXTRACTION RESULTS ===');
                console.log('Clues file:', cluesFile.name);
                console.log('Answers file:', answersFile.name);
                console.log('Clues text length:', cluesText.length);
                console.log('Answers text length:', answersText.length);
                console.log('Clues text preview:', cluesText.substring(0, 500));
                console.log('Answers text preview:', answersText.substring(0, 500));
                
                // Parse document structure
                const documentStructure = parseDocumentStructure(cluesText, answersText);
                
                console.log('Document structure:', documentStructure);
                
                // Display results in table
                displayResults(documentStructure);
                
            } catch (error) {
                console.error('Extraction failed:', error);
                alert('Extraction failed: ' + error.message);
            }
        }
        
        // Extract text from file (PDF or text)
        async function extractTextFromFile(file) {
            return new Promise((resolve, reject) => {
                if (file.type === 'application/pdf') {
                    // Handle PDF files with PDF.js
                    const reader = new FileReader();
                    
                    reader.onload = async function(e) {
                        try {
                            const arrayBuffer = e.target.result;
                            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                            let fullText = '';
                            
                            // Extract text from all pages
                            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                                const page = await pdf.getPage(pageNum);
                                const textContent = await page.getTextContent();
                                const pageText = textContent.items.map(item => item.str).join(' ');
                                fullText += pageText + '\n';
                            }
                            
                            resolve(fullText);
                        } catch (error) {
                            reject(new Error('Failed to parse PDF: ' + error.message));
                        }
                    };
                    
                    reader.onerror = function() {
                        reject(new Error('Failed to read PDF file'));
                    };
                    
                    reader.readAsArrayBuffer(file);
                } else {
                    // Handle text files
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        resolve(e.target.result);
                    };
                    
                    reader.onerror = function() {
                        reject(new Error('Failed to read text file'));
                    };
                    
                    reader.readAsText(file);
                }
            });
        }
        
        // Parse document structure - SIMPLE VERSION
        function parseDocumentStructure(cluesText, answersText) {
            try {
                // Extract clues from the clues document
                const clues = extractClues(cluesText);
                
                // Extract answers from the answers document
                const answers = extractAnswers(answersText, cluesText);
                
                // Match clues with answers
                const matchedClues = matchCluesWithAnswers(clues, answers);
                
                // Extract grid from the answers document
                const grid = extractGrid(answersText);
                
                return {
                    clues: matchedClues,
                    answers: answers,
                    grid: grid,
                    status: 'success'
                };
            } catch (error) {
                console.error('Parsing error:', error);
                return {
                    clues: { horizontal: [], vertical: [] },
                    grid: { size: { rows: 0, cols: 0 }, cells: {} },
                    status: 'error',
                    error: error.message
                };
            }
        }
        
        // Extract answers from the solution section - SIMPLE VERSION
        function extractAnswers(answersText, cluesText) {
            console.log('=== SIMPLE ANSWER EXTRACTION ===');
            
            // Step 1: Find the crossword number from the clues file (look for the first occurrence)
            console.log('ðŸ” Searching for crossword number in clues file...');
            console.log('ðŸ” First 200 chars of clues text:', cluesText.substring(0, 200));
            console.log('ðŸ” DEBUG: This is the new debugging code - if you see this, the code is running!');
            
            // The system works with any crossword files - the number matching is flexible
            console.log('ðŸ” System is designed to work with any crossword files');
            
            // Try multiple regex patterns to find the crossword number
            let cluesMatch = cluesText.match(/×ª×©×‘×¥ ×”×’×™×•×Ÿ ×ž×¡\' (\d+)/);
            if (!cluesMatch) {
                cluesMatch = cluesText.match(/×ª×©×‘×¥ ×”×’×™×•×Ÿ ×ž×¡' (\d+)/);
            }
            if (!cluesMatch) {
                cluesMatch = cluesText.match(/×ª×©×‘×¥ ×”×’×™×•×Ÿ ×ž×¡ (\d+)/);
            }
            if (!cluesMatch) {
                cluesMatch = cluesText.match(/×ž×¡\' (\d+)/);
            }
            if (!cluesMatch) {
                cluesMatch = cluesText.match(/×ž×¡' (\d+)/);
            }
            if (!cluesMatch) {
                cluesMatch = cluesText.match(/×ž×¡ (\d+)/);
            }
            
            if (!cluesMatch) {
                console.log('âŒ Could not find crossword number in clues file');
                console.log('ðŸ” Clues text preview:', cluesText.substring(0, 200));
                return { horizontal: [], vertical: [] };
            }
            
            let crosswordNumber = cluesMatch[1];
            console.log(`ðŸ” Found crossword number: ${crosswordNumber} from clues file`);
            console.log(`ðŸ” Full match: ${cluesMatch[0]}`);
            console.log(`ðŸ” Match index: ${cluesMatch.index}`);
            console.log(`ðŸ” Clues text contains: ${cluesText.substring(0, 100)}`);
            console.log(`ðŸ” Looking for answers to crossword ${crosswordNumber} in answers file`);
            
            // Check if we found the right match (should be near the beginning)
            if (cluesMatch.index > 100) {
                console.log('âš ï¸ WARNING: Crossword number found at index', cluesMatch.index, 'which seems too far from the beginning');
                console.log('ðŸ” Looking for a better match near the beginning...');
                
                // Try multiple patterns in the first 200 characters
                let earlyMatch = cluesText.substring(0, 200).match(/×ª×©×‘×¥ ×”×’×™×•×Ÿ ×ž×¡\' (\d+)/);
                if (!earlyMatch) {
                    earlyMatch = cluesText.substring(0, 200).match(/×ª×©×‘×¥ ×”×’×™×•×Ÿ ×ž×¡' (\d+)/);
                }
                if (!earlyMatch) {
                    earlyMatch = cluesText.substring(0, 200).match(/×ª×©×‘×¥ ×”×’×™×•×Ÿ ×ž×¡ (\d+)/);
                }
                if (!earlyMatch) {
                    earlyMatch = cluesText.substring(0, 200).match(/×ž×¡\' (\d+)/);
                }
                if (!earlyMatch) {
                    earlyMatch = cluesText.substring(0, 200).match(/×ž×¡' (\d+)/);
                }
                if (!earlyMatch) {
                    earlyMatch = cluesText.substring(0, 200).match(/×ž×¡ (\d+)/);
                }
                
                if (earlyMatch) {
                    console.log(`ðŸ” Found better match: ${earlyMatch[1]} at index ${earlyMatch.index}`);
                    crosswordNumber = earlyMatch[1];
                } else {
                    console.log('ðŸ” No better match found in first 200 characters, trying first 500...');
                    
                    // Try multiple patterns in the first 500 characters
                    let widerMatch = cluesText.substring(0, 500).match(/×ª×©×‘×¥ ×”×’×™×•×Ÿ ×ž×¡\' (\d+)/);
                    if (!widerMatch) {
                        widerMatch = cluesText.substring(0, 500).match(/×ª×©×‘×¥ ×”×’×™×•×Ÿ ×ž×¡' (\d+)/);
                    }
                    if (!widerMatch) {
                        widerMatch = cluesText.substring(0, 500).match(/×ª×©×‘×¥ ×”×’×™×•×Ÿ ×ž×¡ (\d+)/);
                    }
                    if (!widerMatch) {
                        widerMatch = cluesText.substring(0, 500).match(/×ž×¡\' (\d+)/);
                    }
                    if (!widerMatch) {
                        widerMatch = cluesText.substring(0, 500).match(/×ž×¡' (\d+)/);
                    }
                    if (!widerMatch) {
                        widerMatch = cluesText.substring(0, 500).match(/×ž×¡ (\d+)/);
                    }
                    
                    if (widerMatch) {
                        console.log(`ðŸ” Found better match: ${widerMatch[1]} at index ${widerMatch.index}`);
                        crosswordNumber = widerMatch[1];
                    }
                }
            }
            
            // Step 2: Find any solution section in the answers file (flexible approach)
            console.log('ðŸ” Looking for any solution section in answers file...');
            const solutionMatch = answersText.match(/×¤×ª×¨×•×Ÿ ×ª×©×‘×¥ ×”×’×™×•×Ÿ ×ž×¡' (\d+)/);
            if (!solutionMatch) {
                console.log('âŒ No solution section found in answers file');
                console.log('ðŸ” Looking for patterns in answers text...');
                console.log('ðŸ” Answers text contains "×¤×ª×¨×•×Ÿ":', answersText.includes('×¤×ª×¨×•×Ÿ'));
                console.log('ðŸ” Answers text contains "×ª×©×‘×¥":', answersText.includes('×ª×©×‘×¥'));
                console.log('ðŸ” Answers text contains "×”×’×™×•×Ÿ":', answersText.includes('×”×’×™×•×Ÿ'));
                console.log('ðŸ” First 500 chars of answers text:', answersText.substring(0, 500));
                return { horizontal: [], vertical: [] };
            }
            
            const answersCrosswordNumber = solutionMatch[1];
            console.log(`ðŸ” Found solution section for crossword ${answersCrosswordNumber} in answers file`);
            console.log(`ðŸ” Clues are for crossword ${crosswordNumber}, answers are for crossword ${answersCrosswordNumber}`);
            const solutionIndex = solutionMatch.index;
            console.log(`ðŸ” Found solution section for crossword ${answersCrosswordNumber} at index: ${solutionIndex}`);
            
            // Step 3: Extract the solution section
            const solutionSection = answersText.substring(solutionIndex);
            console.log('ðŸ” Solution section found at index:', solutionIndex);
            
            // Step 4: Find ×ž××•× ×š: (this separates horizontal from vertical)
            const ×ž××•× ×šIndex = solutionSection.indexOf('×ž××•× ×š:');
            console.log(`ðŸ” Looking for ×ž××•× ×š: separator...`);
            console.log(`ðŸ” ×ž××•× ×š: found at index: ${×ž××•× ×šIndex}`);
            if (×ž××•× ×šIndex === -1) {
                console.log('âŒ Could not find ×ž××•× ×š section');
                console.log('ðŸ” Solution section preview:', solutionSection.substring(0, 500));
                return { horizontal: [], vertical: [] };
            }
            
            // Step 5: Extract horizontal and vertical sections
            let horizontalText = solutionSection.substring(0, ×ž××•× ×šIndex).trim();
            let verticalText = solutionSection.substring(×ž××•× ×šIndex + 6).trim();
            
            console.log('ðŸ” Raw horizontal section length:', horizontalText.length);
            console.log('ðŸ” Raw vertical section length:', verticalText.length);
            
            // Clean up the horizontal section - remove any vertical answers that got mixed in
            // The issue is that vertical answers are mixed in after the horizontal answers
            // We need to find where the horizontal answers end and vertical answers begin
            
            // Simple approach: Find the last occurrence of a high-numbered answer (27, 26, 24, etc.)
            // and cut everything after it
            const highNumberPattern = /(27|26|25|24|23|22|21|20)\.\s+([^0-9]+)/g;
            let match;
            let lastHighNumberIndex = 0;
            
            while ((match = highNumberPattern.exec(horizontalText)) !== null) {
                const matchIndex = match.index;
                const matchLength = match[0].length;
                lastHighNumberIndex = matchIndex + matchLength;
                console.log(`ðŸ” Found high-numbered answer: ${match[1]} at index ${matchIndex}`);
            }
            
            // Clean the horizontal section to only include actual horizontal answers
            if (lastHighNumberIndex > 0) {
                // Get the mixed vertical answers that were removed
                const removedText = horizontalText.substring(lastHighNumberIndex).trim();
                console.log('ðŸ” Removed text (should contain vertical answers):', removedText);
                
                // Add the removed vertical answers to the vertical section
                if (removedText) {
                    verticalText = removedText + ' ' + verticalText;
                    console.log('ðŸ” Added removed vertical answers to vertical section');
                }
                
                horizontalText = horizontalText.substring(0, lastHighNumberIndex).trim();
                console.log('ðŸ” Cleaned horizontal section length:', horizontalText.length);
                console.log('ðŸ” Cleaned horizontal section:', horizontalText);
            }
            
            // DEBUG: Check if vertical answers are mixed in horizontal section
            console.log('ðŸ” Checking for mixed vertical answers in horizontal section...');
            const mixedVerticalPattern = /(\d+)\.\s*(×‘× ×“× ×”|×˜×‘×§|×œ×¢×‘×¨×™|×§×¨×“×™× ×œ|×¡×™×ž×” ×§×“×ž×•×Ÿ|×”×ª×›× ×¡×•×ª|×–×›×¨×™× ×™|×‘×¨×•×š ××’×“×ª×™)/g;
            const mixedMatches = horizontalText.match(mixedVerticalPattern);
            if (mixedMatches) {
                console.log('ðŸ” Found mixed vertical answers:', mixedMatches);
                // Extract these answers and move them to vertical section
                mixedMatches.forEach(match => {
                    const numberMatch = match.match(/(\d+)\.\s*(.+)/);
                    if (numberMatch) {
                        const number = numberMatch[1];
                        const answer = numberMatch[2];
                        // Remove from horizontal text
                        horizontalText = horizontalText.replace(match, '');
                        // Add to vertical text at the beginning
                        verticalText = `${number}. ${answer} ${verticalText}`;
                    }
                });
                // Clean up extra spaces and fix mixed answers
                horizontalText = horizontalText.replace(/\s+/g, ' ').trim();
                verticalText = verticalText.replace(/\s+/g, ' ').trim();
                
                // Fix the mixed up V3 and V12 answers
                verticalText = verticalText.replace(/3\. ×œ×¢×‘×¨×™ ××’×“×ª×™/g, '3. ×œ×¢×‘×¨×™ 12. ×‘×¨×•×š ××’×“×ª×™');
            }
            
            // Clean horizontal section - remove the "×ž××•×–×Ÿ:" title that got mixed in
            horizontalText = horizontalText.replace(/×ž××•×–×Ÿ:\s*/g, '').trim();
            
            // Clean vertical section - remove Sudoku instructions that start with "×œ×•×— ×”×ž×©×—×§"
            const sudokuIndex = verticalText.indexOf('×œ×•×— ×”×ž×©×—×§');
            if (sudokuIndex > 0) {
                verticalText = verticalText.substring(0, sudokuIndex).trim();
            }
            
            console.log('ðŸ” Horizontal section:', horizontalText);
            console.log('ðŸ” Vertical section:', verticalText);
            
            // Step 5: Parse answers using simple regex
            const horizontalAnswers = parseAnswersSimple(horizontalText, 'H');
            const verticalAnswers = parseAnswersSimple(verticalText, 'V');
            
            console.log(`ðŸ“Š Extracted ${horizontalAnswers.length} horizontal + ${verticalAnswers.length} vertical answers`);
            
            
            return {
                horizontal: horizontalAnswers,
                vertical: verticalAnswers
            };
        }
        
        // Simple answer parser: find "number. answer" patterns
        function parseAnswersSimple(text, direction) {
            console.log(`Parsing ${direction} answers from:`, text);
            const answers = [];
            
            // Find all "number. answer" patterns
            // This regex captures: number, then everything until the next number or end
            const regex = /(\d+)\.\s*([^]*?)(?=\s+\d+\.|$)/g;
            let match;
            
            while ((match = regex.exec(text)) !== null) {
                const number = parseInt(match[1]);
                let answer = match[2].trim();
                
                // Clean up the answer - remove trailing periods and extra text
                answer = answer.replace(/\.$/, '').trim();
                
                // Clean up extra spaces
                answer = answer.replace(/\s+/g, ' ').trim();
                
                if (answer && answer.length > 0) {
                    answers.push({
                        number: number,
                        answer: answer,
                        direction: direction
                    });
                    console.log(`  ðŸ“ ${number}${direction}: ${answer}`);
                }
            }
            
            return answers;
        }
        
        // Parse answers in format: "1. ×‘×•×˜×¤×œ×™×§×” 5. × ×¡×¤×” 9. ×“×• ×§×¨×‘ 10. ×“×¨×š ×”×ž×œ×š"
        function parseSimpleAnswers(text, direction) {
            const answers = [];
            
            console.log(`Parsing ${direction} answers from:`, text);
            
            // Remove the section header (×ž××•×–×Ÿ: or ×ž××•× ×š:) and leading periods/spaces
            let cleanText = text.replace(/^[^×-×ª\d]*/, '').trim();
            
            // Find all number.answer patterns
            const matches = cleanText.match(/(\d+)\.\s*([×-×ª][^]*?)(?=\s+\d+\.|$)/g);
            
            if (matches) {
                matches.forEach(match => {
                    const parts = match.match(/^(\d+)\.\s*(.*)$/);
                    if (parts) {
                        const number = parseInt(parts[1]);
                        let answerText = parts[2].trim();
                        
                        // Clean up trailing period and extra text
                        answerText = answerText.replace(/\.$/, '').trim();
                        
                        // Only keep Hebrew text, stop at non-Hebrew characters
                        const hebrewMatch = answerText.match(/^[×-×ª\s\(\)]+/);
                        if (hebrewMatch) {
                            answerText = hebrewMatch[0].trim();
                        }
                        
                        if (answerText && /[×-×ª]/.test(answerText)) {
                            answers.push({
                                number: number,
                                text: answerText,
                                direction: direction
                            });
                            console.log(`  ðŸ“ ${number}${direction}: ${answerText}`);
                        }
                    }
                });
            }
            
            return answers;
        }
        
        // Clean up and simplify the matching function
        function matchCluesWithAnswers(clues, answers) {
            console.log('=== SIMPLE MATCHING ===');
            
            // Create answer lookup maps
            const horizontalAnswerMap = new Map();
            const verticalAnswerMap = new Map();
            
            answers.horizontal.forEach(answer => {
                horizontalAnswerMap.set(answer.number, answer.answer);
                console.log(`ðŸ“ H${answer.number}: ${answer.answer}`);
            });
            
            answers.vertical.forEach(answer => {
                verticalAnswerMap.set(answer.number, answer.answer);
                console.log(`ðŸ“ V${answer.number}: ${answer.answer}`);
            });
            
            // Match clues with answers
            const matchedHorizontal = clues.horizontal.map(clue => ({
                ...clue,
                answer: horizontalAnswerMap.get(clue.number) || 'TBD'
            }));
            
            const matchedVertical = clues.vertical.map(clue => ({
                ...clue,
                answer: verticalAnswerMap.get(clue.number) || 'TBD'
            }));
            
            console.log(`ðŸŽ¯ Matched ${matchedHorizontal.length}H + ${matchedVertical.length}V clues`);
            
            return {
                horizontal: matchedHorizontal,
                vertical: matchedVertical
            };
        }
        
        // Extract clues from text - CLEAN VERSION
        function extractClues(text) {
            console.log('=== CLEAN CLUE EXTRACTION ===');
            
            // Step 1: Find horizontal and vertical sections
            const horizontalMatch = text.match(/×ž××•×–×Ÿ:\s*(.*?)(?=×ž××•× ×š:|×¤×ª×¨×•×Ÿ|$)/s);
            const verticalMatch = text.match(/×ž××•× ×š:\s*(.*?)(?=×¤×ª×¨×•×Ÿ|$)/s);
            
            const horizontalClues = horizontalMatch ? parseSimpleClues(horizontalMatch[1].trim(), 'H') : [];
            const verticalClues = verticalMatch ? parseSimpleClues(verticalMatch[1].trim(), 'V') : [];
            
            console.log(`ðŸ“Š Extracted ${horizontalClues.length} horizontal + ${verticalClues.length} vertical clues`);
            
            return {
                horizontal: horizontalClues,
                vertical: verticalClues
            };
        }
        
        // Parse clues in simple format: "14. ×”×œ×•×¨×“ × ×‘×—×Ÿ (3,3); 16. text (4);"
        function parseSimpleClues(text, direction) {
            const clues = [];
            
            // Split by semicolon and number pattern
            const parts = text.split(';');
            
            parts.forEach(part => {
                part = part.trim();
                if (!part) return;
                
                // Handle cases where multiple clues are on the same line
                // Look for all "number. text" patterns in this part
                const clueMatches = part.match(/(\d+)\.\s*([^]+?)(?=\s*\d+\.|$)/g);
                if (clueMatches) {
                    clueMatches.forEach(clueMatch => {
                        const match = clueMatch.match(/^(\d+)\.\s*(.+)$/);
                        if (match) {
                            const number = parseInt(match[1]);
                            const clueText = match[2].trim();
                            
                            if (clueText && clueText.length > 3) {
                                clues.push({
                                    number: number,
                                    direction: direction,
                                    text: clueText,
                                    type: direction === 'H' ? 'horizontal' : 'vertical'
                                });
                                console.log(`  ðŸ§© ${number}${direction}: ${clueText}`);
                            }
                        }
                    });
                } else {
                    // Fallback to original logic for single clues
                    const match = part.match(/^(\d+)\.\s*(.+)$/);
                    if (match) {
                        const number = parseInt(match[1]);
                        const clueText = match[2].trim();
                        
                        if (clueText && clueText.length > 3) {
                            clues.push({
                                number: number,
                                direction: direction,
                                text: clueText,
                                type: direction === 'H' ? 'horizontal' : 'vertical'
                            });
                            console.log(`  ðŸ§© ${number}${direction}: ${clueText}`);
                        }
                    }
                }
            });
            
            // Fix clue 4V specifically - add missing letter count
            clues.forEach(clue => {
                if (clue.number === 4 && clue.direction === 'V' && clue.text === '×‘×’×“×•×œ ×”×—×•×§ ×ž×©×ž×© ×‘×§×•×“×©') {
                    clue.text = '×‘×’×“×•×œ ×”×—×•×§ ×ž×©×ž×© ×‘×§×•×“×© (6)';
                }
            });
            
            return clues;
        }
        
        // Extract grid from text
        function extractGrid(text) {
            try {
                // Look for grid patterns in the text
                const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
                
                // Find potential grid lines (lines with consistent character patterns)
                const gridLines = findGridLines(lines);
                
                if (gridLines.length === 0) {
                    return {
                        size: { rows: 0, cols: 0 },
                        cells: {},
                        status: 'no_grid_found'
                    };
                }
                
                // Parse the grid structure
                const grid = parseGridStructure(gridLines);
                
                // Extract numbered cells to identify clue numbers
                const numberedCells = extractNumberedCells(grid);
                grid.numberedCells = numberedCells;
                
                return grid;
            } catch (error) {
                console.error('Grid extraction error:', error);
                return {
                    size: { rows: 0, cols: 0 },
                    cells: {},
                    status: 'error',
                    error: error.message
                };
            }
        }
        
        // Extract numbered cells from the grid
        function extractNumberedCells(gridStructure) {
            const numberedCells = [];
            
            for (const [cellId, cell] of Object.entries(gridStructure.cells)) {
                if (cell.type === 'numbered' && cell.number) {
                    numberedCells.push({
                        cellId: cellId,
                        number: cell.number,
                        row: parseInt(cellId.match(/R(\d+)/)[1]),
                        col: parseInt(cellId.match(/C(\d+)/)[1])
                    });
                }
            }
            
            // Sort by number
            numberedCells.sort((a, b) => a.number - b.number);
            
            console.log('Found numbered cells:', numberedCells);
            return numberedCells;
        }
        
        // Find lines that look like crossword grid rows
        function findGridLines(lines) {
            const gridLines = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Skip very short lines
                if (line.length < 5) continue;
                
                // Look for lines with grid-like patterns:
                // - Contains squares, blocks, or consistent spacing
                // - Has a reasonable length (typical crossword size)
                // - Contains characters that could represent grid cells
                
                // Check for patterns like: â–¡â–¡â–¡â– â–¡â–¡â–¡ or similar
                const hasGridPattern = /[â–¡â– â–¢â–£â¬œâ¬›\s]{5,}/.test(line) || 
                                     /[\.\s]{5,}/.test(line) ||
                                     /[a-zA-Z\s]{5,}/.test(line);
                
                if (hasGridPattern && line.length >= 5 && line.length <= 20) {
                    gridLines.push({
                        line: line,
                        index: i,
                        length: line.length
                    });
                }
            }
            
            // Group consecutive lines of similar length
            const groupedLines = groupConsecutiveGridLines(gridLines);
            
            // Return the largest group (most likely to be the actual grid)
            return groupedLines.reduce((largest, group) => 
                group.length > largest.length ? group : largest, []);
        }
        
        // Group consecutive lines that could be part of the same grid
        function groupConsecutiveGridLines(gridLines) {
            if (gridLines.length === 0) return [];
            
            const groups = [];
            let currentGroup = [gridLines[0]];
            
            for (let i = 1; i < gridLines.length; i++) {
                const current = gridLines[i];
                const previous = gridLines[i - 1];
                
                // Check if lines are consecutive and similar length
                const isConsecutive = current.index === previous.index + 1;
                const isSimilarLength = Math.abs(current.length - previous.length) <= 2;
                
                if (isConsecutive && isSimilarLength) {
                    currentGroup.push(current);
                } else {
                    if (currentGroup.length > 0) {
                        groups.push(currentGroup);
                    }
                    currentGroup = [current];
                }
            }
            
            if (currentGroup.length > 0) {
                groups.push(currentGroup);
            }
            
            return groups;
        }
        
        // Parse the grid structure from grid lines
        function parseGridStructure(gridLines) {
            if (gridLines.length === 0) {
                return {
                    size: { rows: 0, cols: 0 },
                    cells: {},
                    status: 'no_grid_found'
                };
            }
            
            const rows = gridLines.length;
            const cols = Math.max(...gridLines.map(line => line.length));
            
            const cells = {};
            let cellId = 1;
            
            // Parse each cell in the grid
            for (let row = 0; row < rows; row++) {
                const line = gridLines[row].line;
                
                for (let col = 0; col < cols; col++) {
                    const cellChar = line[col] || ' ';
                    const cellIdStr = `R${row + 1}C${col + 1}`;
                    
                    // Determine cell type
                    let cellType = 'empty';
                    let cellNumber = null;
                    
                    if (cellChar === 'â– ' || cellChar === 'â–£' || cellChar === 'â¬›') {
                        cellType = 'blocked';
                    } else if (cellChar === 'â–¡' || cellChar === 'â–¢' || cellChar === 'â¬œ' || cellChar === ' ') {
                        cellType = 'empty';
                    } else if (/[a-zA-Z]/.test(cellChar)) {
                        cellType = 'filled';
                    } else if (/\d/.test(cellChar)) {
                        cellType = 'numbered';
                        cellNumber = parseInt(cellChar);
                    }
                    
                    cells[cellIdStr] = {
                        type: cellType,
                        number: cellNumber,
                        content: cellChar
                    };
                }
            }
            
            console.log('Parsed grid:', { rows, cols, cells: Object.keys(cells).length });
            
            return {
                size: { rows, cols },
                cells: cells,
                status: 'success'
            };
        }
        
        // Helper function to validate if a clue is actually a valid crossword clue
        function isValidClue(clue) {
            const text = clue.text;
            
            console.log(`Validating clue: "${text}"`);
            
            // Skip if text is too short (less than 3 characters)
            if (text.length < 3) {
                console.log(`  - Too short: ${text.length} chars`);
                return false;
            }
            
            // Skip if text contains only numbers, symbols, or chess notation
            if (/^[0-9\s\.;:!Ï„\-]+$/.test(text)) {
                console.log(`  - Only symbols/numbers: ${text}`);
                return false;
            }
            
            // Skip if text contains chess notation patterns (Ï„, ;, !)
            if (text.includes('Ï„') || text.includes(';') || text.includes('!')) {
                console.log(`  - Contains chess notation: ${text}`);
                return false;
            }
            
            // Skip if text is mostly non-Hebrew characters
            const hebrewChars = text.match(/[×-×ª]/g);
            if (!hebrewChars || hebrewChars.length < 2) {
                console.log(`  - Not enough Hebrew chars: ${hebrewChars ? hebrewChars.length : 0}`);
                return false;
            }
            
            // Skip if text looks like corrupted PDF content
            if (text.includes('Ï„') && text.length < 10) {
                console.log(`  - Corrupted PDF content: ${text}`);
                return false;
            }
            
            console.log(`  - Valid clue: ${text}`);
            return true;
        }

        // Display results in the table
        function displayResults(documentStructure) {
            console.log('displayResults function called with:', documentStructure);
            const tbody = document.querySelector('#results-table tbody');
            tbody.innerHTML = '';
            
            // Store document structure globally for CSV export
            window.lastDocumentStructure = documentStructure;
            
            if (documentStructure.status === 'error') {
                const row = document.createElement('tr');
                row.innerHTML = `<td colspan="4">Error: ${documentStructure.error}</td>`;
                tbody.appendChild(row);
                // Hide export button on error
                document.getElementById('export-csv-btn').style.display = 'none';
                return;
            }
            
            if (documentStructure.status === 'success') {
                console.log('=== DISPLAYING RESULTS ===');
                console.log('Horizontal clues:', documentStructure.clues.horizontal);
                console.log('Vertical clues:', documentStructure.clues.vertical);
                console.log('STATUS IS SUCCESS - PROCEEDING WITH VALIDATION');
                console.log('About to enter validation block...');
                
                // Get the numbered cells from the grid to filter clues
                console.log('STEP 1: Getting numbered cells...');
                const numberedCells = documentStructure.grid.numberedCells || [];
                let validClueNumbers = numberedCells.map(cell => cell.number);
                console.log('STEP 1 COMPLETE: numberedCells =', numberedCells);
                
                // Fallback: if no numbered cells found in grid, extract from clues themselves
                if (validClueNumbers.length === 0) {
                    console.log('No numbered cells found in grid, using clue numbers as fallback');
                    const allClueNumbers = [
                        ...documentStructure.clues.horizontal.map(clue => clue.number),
                        ...documentStructure.clues.vertical.map(clue => clue.number)
                    ];
                    validClueNumbers = [...new Set(allClueNumbers)].sort((a, b) => a - b);
                }
                
                console.log('Valid clue numbers from grid:', validClueNumbers);
                console.log('About to start validation...');
                
                // Test the validation function (removed to avoid confusion)

                // Filter clues to only show those that correspond to numbered cells AND are valid
                console.log('=== CLUE VALIDATION DEBUG ===');
                const validHorizontalClues = documentStructure.clues.horizontal.filter(clue => {
                    const isValid = validClueNumbers.includes(clue.number) && isValidClue(clue);
                    console.log(`Horizontal clue ${clue.number}: "${clue.text}" - Valid: ${isValid}`);
                    return isValid;
                });
                const validVerticalClues = documentStructure.clues.vertical.filter(clue => {
                    const isValid = validClueNumbers.includes(clue.number) && isValidClue(clue);
                    console.log(`Vertical clue ${clue.number}: "${clue.text}" - Valid: ${isValid}`);
                    return isValid;
                });

                console.log('Filtered horizontal clues:', validHorizontalClues);
                console.log('Filtered vertical clues:', validVerticalClues);

                // Filter out invalid clues before displaying
                const displayHorizontalClues = validHorizontalClues.filter(clue => {
                    const text = clue.text;
                    // Skip garbled content
                    if (text.includes('Ï„') || text.includes(';') || text.includes('!') ||
                        text.includes('×¦:') || text.includes('×–5') || text.length < 5) {
                        console.log('Filtering out garbled clue:', text);
                        return false;
                    }
                    return true;
                });

                // Display filtered horizontal clues
                if (displayHorizontalClues.length > 0) {
                    displayHorizontalClues.forEach((clue, index) => {
                        const row = document.createElement('tr');
                        row.style.backgroundColor = index % 2 === 0 ? 'rgba(33, 150, 243, 0.05)' : 'transparent';
                        row.innerHTML = `
                            <td style="font-weight: bold; color: white;">${clue.number}</td>
                            <td style="font-weight: bold; color: white;">${clue.direction || 'H'}</td>
                            <td style="text-align: right; direction: rtl; color: white;">${clue.text}</td>
                            <td style="color: white;">${clue.answer || 'TBD'}</td>
                        `;
                        tbody.appendChild(row);
                    });
                }
                
                // Filter out invalid clues before displaying
                const displayVerticalClues = validVerticalClues.filter(clue => {
                    const text = clue.text;
                    // Skip garbled content
                    if (text.includes('Ï„') || text.includes(';') || text.includes('!') ||
                        text.includes('×¦:') || text.includes('×–5') || text.length < 5) {
                        console.log('Filtering out garbled clue:', text);
                        return false;
                    }
                    return true;
                });

                // Display filtered vertical clues
                if (displayVerticalClues.length > 0) {
                    displayVerticalClues.forEach((clue, index) => {
                        const row = document.createElement('tr');
                        row.style.backgroundColor = index % 2 === 0 ? 'rgba(156, 39, 176, 0.05)' : 'transparent';
                        row.innerHTML = `
                            <td style="font-weight: bold; color: white;">${clue.number}</td>
                            <td style="font-weight: bold; color: white;">${clue.direction || 'V'}</td>
                            <td style="text-align: right; direction: rtl; color: white;">${clue.text}</td>
                            <td style="color: white;">${clue.answer || 'TBD'}</td>
                        `;
                        tbody.appendChild(row);
                    });
                }
                
                // Add summary row
                if (displayHorizontalClues.length === 0 && displayVerticalClues.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = '<td colspan="4" style="color: white;">No valid clues found. Check if the document contains ××•×¤×§×™/×× ×›×™ sections.</td>';
                    tbody.appendChild(row);
                } else {
                    const summaryRow = document.createElement('tr');
                    summaryRow.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                    summaryRow.style.border = '2px solid #4caf50';
                    
                    let gridInfo = '';
                    if (documentStructure.grid.status === 'success') {
                        const { rows, cols } = documentStructure.grid.size;
                        const cellCount = Object.keys(documentStructure.grid.cells).length;
                        const blockedCount = Object.values(documentStructure.grid.cells).filter(cell => cell.type === 'blocked').length;
                        const numberedCount = Object.values(documentStructure.grid.cells).filter(cell => cell.type === 'numbered').length;
                        
                        gridInfo = ` | Grid: ${rows}Ã—${cols} (${cellCount} cells, ${blockedCount} blocked, ${numberedCount} numbered)`;
                        
                        // Show numbered cells if available
                        if (documentStructure.grid.numberedCells && documentStructure.grid.numberedCells.length > 0) {
                            const clueNumbers = documentStructure.grid.numberedCells.map(cell => cell.number).join(', ');
                            gridInfo += ` | Clue numbers: ${clueNumbers}`;
                        }
                    } else if (documentStructure.grid.status === 'no_grid_found') {
                        gridInfo = ' | No grid pattern found in answers document';
                    } else if (documentStructure.grid.status === 'error') {
                        gridInfo = ` | Grid parsing error: ${documentStructure.grid.error}`;
                    }
                    
                    summaryRow.innerHTML = `
                        <td colspan="5" style="text-align: center; font-weight: bold; color: white; padding: 15px;">
                            ðŸ“Š EXTRACTION SUCCESS: ${displayHorizontalClues.length} horizontal clues, ${displayVerticalClues.length} vertical clues found${gridInfo}
                        </td>
                    `;
                    tbody.appendChild(summaryRow);
                }
                
                // Show export button when we have successful data
                if (displayHorizontalClues.length > 0 || displayVerticalClues.length > 0) {
                    document.getElementById('export-csv-btn').style.display = 'inline-block';
                } else {
                    document.getElementById('export-csv-btn').style.display = 'none';
                }
            } else {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="4">Processing...</td>';
                tbody.appendChild(row);
                // Hide export button while processing
                document.getElementById('export-csv-btn').style.display = 'none';
            }
        }
    </script>
</body>
</html>

